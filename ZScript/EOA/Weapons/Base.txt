Class EffectBase1 : Actor
{
	Default
	{
		RenderStyle "Add";
		+NOINTERACTION
		+CLIENTSIDEONLY
		+FORCEXYBILLBOARD
		+NOBLOCKMAP
		+DONTSPLASH
		+THRUACTORS
		+NOTRIGGER
		//-ACTIVATEPCROSS
		//-ACTIVATEIMPACT
		+NOBLOCKMAP
		+NOBLOCKMONST
		+NOTONAUTOMAP
		+CANNOTPUSH
		+ROLLSPRITE
		+INTERPOLATEANGLES
		Radius 0.5;
		Height 1;
		Gravity 0.66;
		Species "VFX";
	}
	States
	{
	Spawn:
		TNT1 A 10;
		Stop;
	}
}

Class TrailSpawner : EffectBase1
{
	Default { Height 0;}
	Override Void Tick()
	{
		Super.Tick();
		If(!Target)
		{
			Destroy();
			Return;
		}
		If(!IsFrozen())
		{
			SetXYZ(Target.Pos);
			If(Tracer)
			{
				Tracer.A_FaceTarget(0,0,180,90,FAF_BOTTOM);
				Tracer.Scale.Y=(Distance3D(Tracer)/64);
			}
			If(special1%ReactionTime==0)
			{
				Tracer=Spawn("LightningBeamTrailBase1",Pos);
				If(Tracer)
				{
					Tracer.Translation=Translation;
					Tracer.Height=0;
					Tracer.Target=Self;
					Tracer.Tics=Health;
					Tracer.Scale.X=Scale.X;
					Tracer.Frame=Frame;
					Tracer.Health=1;
					Tracer.Speed=Speed;
					Tracer.bBright=bBright;
					Tracer.A_SetRenderStyle(Alpha,GetRenderStyle());
					Tracer.SetShade(FillColor);
				}
			}
			If(Tracer)
			{
				Tracer.A_FaceTarget(0,0,180,90,FAF_BOTTOM);
				Tracer.Scale.Y=(Distance3D(Tracer)/64);
			}
			special1++;
		}
	}
	States
	{
	Spawn:
		TNT1 A -1;
		Stop;
	}
}

//TheCamaleonMaligno why
Class StunMeDaddy : Powerup
{
	Override Void InitEffect()
	{
		special1=Max(Owner.Tics,5);
	}
	Override Void DoEffect()
	{
		If(Owner.Health>0)
		Owner.Tics=special1;
	}
}

Class LightningBeamBase1 : EffectBase1 // Based on D4D's lightning effect... in other words: plagiarism. Btw thanks Major Cooke!
{
	Default
	{
		Height 0;
		Health 64; // Step Dist
		Mass 2048; // Max Dist
		ReactionTime 7; // Random Turn
		MeleeRange 1; // Step split
		+NOSECTOR
	}
	int framen;
	double dist[2];
	int warpflags;
	int stepsplit;
	double segmentsize;
	vector2 offsetis;
	Void A_Face()
	{
		If(!Tracer)
		Return;
		MakeActorFace(Self,Tracer,Height);
		/*
		Double SaveMyHeight=Height;
		Double SaveHeight=Tracer.Height;
		Bool SaveShadow=Tracer.bShadow;
		Tracer.Height=Height=Tracer.bShadow=0;
		If(SaveMyHeight>0)
		Tracer.AddZ(SaveMyHeight);
		A_FaceTracer(0,0);
		Pitch*=-1;
		If(SaveMyHeight>0)
		Tracer.AddZ(-SaveMyHeight);
		Tracer.bShadow=SaveShadow;
		Tracer.Height=SaveHeight;
		Height=SaveMyHeight;*/
	}
	Void MakeActorFace(Actor Who, Actor Targ, Double HeightOffs)
	{
		If(!Who || !Targ) Return;
		Vector2 Dir=EOA_Weapon.FaceVector(Targ.Pos+(0,0,HeightOffs),Who.Pos);
		Who.Angle=Dir.X;
		Who.Pitch=-Dir.Y;
	}
	States
	{
	Spawn:
		TNT1 A 3 NoDelay {
		SetXYZ(Pos-Vel);
		dist[1]=int(Min(Mass,Distance3D(TRACER)));
		A_Face();
		segmentsize=(Health*10000000/64)*0.0000001;
		If(!bThruActors)
		{ warpflags=WARPF_NOCHECKPOSITION; }
		Return A_JumpIf(IsPointerEqual(AAPTR_TRACER,AAPTR_NULL),"Null");
		}
	Fly:
		TNT1 A 0 {
			A_Face();
			If(Distance3D(TRACER)>Health || dist[0]<dist[1])
			{
				Pitch+=FRandom(-ReactionTime,ReactionTime);
				Angle+=FRandom(-ReactionTime,ReactionTime);
			}
			If(Distance3D(TRACER)<=Health*2)
			A_Face();
			dist[0]+=Health;
			Return ResolveState("Missile");
		}
	Missile:
		TNT1 A 0
		{
			actor diomio;
			int wea;
			If(Distance3D(TRACER)<Health || dist[0]>dist[1])
			{ Scale.Y=-(Distance3D(TRACER)/Health); Health=-int(Scale.Y); A_Face(); }
			If(dist[0]>dist[1])
			{ SetXYZ(Pos-(cos(-pitch)*(Health/MeleeRange),0,sin(pitch)*(Health/MeleeRange))); A_Face(); }
			[wea, diomio]=A_SpawnItemEx("LightningBeamTrailBase1",cos(-pitch)*(Health),0,sin(pitch)*(Health),0,0,0,0,SXF_TRANSFERPITCH|1|SXF_TRANSFERALPHA|SXF_TRANSFERSTENCILCOL);
			If(diomio)
			{
				diomio.A_SetRenderStyle(alpha,GetRenderStyle());
				diomio.pitch+=90;
				diomio.frame=framen;
				diomio.Scale=(Scale.X,Scale.Y*segmentsize);
				diomio.bNoTimeFreeze=bNoTimeFreeze;
				diomio.prev=diomio.pos+vel;
				diomio.health=damage;
				diomio.speed=speed;
				diomio.specialf1=specialf1;
				
			}
			If(Distance3D(TRACER)<Health)
			{Return ResolveState("XDeath");}
			Return ResolveState("Move");
		}
		Goto Move;
	Move:
		TNT1 A 0 {
			for(stepsplit=0;stepsplit<MeleeRange;stepsplit++)
			{
				If(dist[0]>dist[1] || Distance3D(TRACER)<Health)
				{
					If(dist[0]>=Mass)
					{Return ResolveState("Null");}
					Else{Return ResolveState("XDeath");}
				}
				If(!A_Warp(AAPTR_DEFAULT,cos(-pitch)*(Health/MeleeRange),0,sin(pitch)*(Health/MeleeRange),0,warpflags,"Null"))
				{Return ResolveState("Death");}
			}
			Return ResolveState("Fly");
		}

	Spawn:
		TNT1 A 0 NoDelay
		{
			If(!Tracer) { Destroy(); Return; }
			SetXYZ(Pos-Vel);
			dist[1]=Min(Mass,EOA_Weapon.VectorLength(Pos,Tracer.Pos+(0,0,Height)));
			If(dist[1]<10) { Destroy(); Return; }
			If(dist[1]<=Health*2) Health=int(dist[1]/2);
			specialf2=Dist[1]*0.75;
			A_Face();
			//A_SpawnParticle("White",SPF_FULLBRIGHT|SPF_RELATIVE,1,20.0);
		}
	Fly:
		TNT1 A 0
		{
			////A_SpawnParticle("Green",SPF_FULLBRIGHT|SPF_RELATIVE,1,10.0,0,0,Offsetis.X,0,1);
			//A_SpawnParticle("Green",SPF_FULLBRIGHT|SPF_RELATIVE,1,10.0);
			actor target=Spawn("LightningBeamTrailBase1",Pos,ALLOW_REPLACE);
			If(target)
			{
				If(lastenemy)
				{
					lastenemy.tracer=target;
					//MakeActorFace(target,lastenemy,0);
					//lastenemy.A_SpawnParticle("gray",SPF_FULLBRIGHT|SPF_RELATIVE,1,10.0,velx:16);
					//lastenemy.Scale.Y=(lastenemy.Distance3D(target)/64);
					//lastenemy.pitch+=90;
					/*
					if(!special1)
					{
						special1++;
						lastenemy.angle+=180;
					}*/
				}
				target.bBright=True;
				target.Translation=Translation;
				target.A_SetRenderStyle(alpha,GetRenderStyle());
				target.SetShade(FillColor);
				//target.pitch+=90;
				target.frame=framen;
				target.Scale.X=Scale.X;
				target.bNoTimeFreeze=bNoTimeFreeze;
				target.health=damage;
				target.speed=speed;
				target.specialf1=specialf1;
				//target.prev=target.pos+vel; had to move this a few lines below
				lastenemy=target;
			}
			A_Warp(AAPTR_DEFAULT,cos(-pitch)*Health,0,sin(pitch)*Health,0,WARPF_NOCHECKPOSITION);
			Double DistToTarget=EOA_Weapon.VectorLength(Pos,Tracer.Pos+(0,0,Height));
			Double DistFromStart=EOA_Weapon.VectorLength(Pos,SpawnPoint);
				/*If(Ticker>=SpiralDecreaseDist && SpiralIncreaseSpeed>0)
				{
					SpiralIncreaseSpeed=SpiralDist*Speed/(Dist-Ticker);
					//A_LogFloat(SpiralIncreaseSpeed);
					SpiralIncreaseSpeed*=-1;
					MaxedSpiral=False;
				}*/
			//target.A_Warp(AAPTR_DEFAULT,Cos(Angle)*Offsetis.X,Sin(Angle)*Offsetis.X,0,0,WARPF_NOCHECKPOSITION|WARPF_USECALLERANGLE);
			target.SetXYZ(Target.pos+ (   RotateVector((Sin(-Pitch)*Offsetis.Y,Offsetis.X),Angle),Cos(-Pitch)*Offsetis.Y   ));
			target.prev=target.pos+vel;
			Vector2 RandomOffs=(FRandom(-ReactionTime,ReactionTime),FRandom(-ReactionTime,ReactionTime));
			Offsetis+=RandomOffs*0.5;
			//Offsetis+=(0,5);
			If(DistToTarget<=dist[1]*0.33)
			{
				//A_SpawnParticle("Blue",SPF_FULLBRIGHT|SPF_RELATIVE,1,20.0);
				Double Restante=DistFromStart-dist[1]*0.33;
				Double Factor=DistToTarget/(dist[1]*0.33);
				//a_logfloat(factor);
				OFfsetis*=Factor;
			}

			If(DistToTarget<=Health || DistFromStart>Mass)
			{
				//If(DistToTarget<=Health)
				SetXYZ(Tracer.Pos+(0,0,Height));
				//A_SpawnParticle("Yellow",SPF_FULLBRIGHT|SPF_RELATIVE,1,15.0);
				If(target)
				{
					target.tracer=self;
				}
				SetStateLabel("Ded");
				Return;
			}
			//Return ResolveState("Missile");
		}
		Loop;
	Ded:
		TNT1 A 1;
		Stop;
	XDeath:
		TNT1 A 0 {A_Warp(AAPTR_TRACER,0,0,0,0,WARPF_NOCHECKPOSITION);
		Return ResolveState("XDeathAnim");}
		Stop;
	Death:
		TNT1 A 0 {A_Warp(AAPTR_TRACER,0,0,0,0,WARPF_NOCHECKPOSITION);
		Return ResolveState("DeathAnim");}
		Stop;
	XDeathAnim:
	DeathAnim:
		TNT1 A 0;
		Stop;
	}
}
Class LightningBeamTrailBase1 : EffectBase1
{
	Default
	{
		Height 0;
		Speed 64;
		-INTERPOLATEANGLES
		//+DONTINTERPOLATE
		//XScale 0.25;
		//+ROLLSPRITE
		//+FLATSPRITE
	}
	Override Void PostBeginPlay()
	{
		Super.PostBeginPlay();
		FaceTracer();
	}
	Void FaceTracer()
	{
		If(!Tracer) Return;
		A_FaceTracer(0,0,0,0,FAF_BOTTOM);
		Scale.Y=(Distance3D(tracer)/64);
		pitch+=90;
		pitch*=-1;
		//angle+=180;
	}
	Override Void Tick()
	{
		Super.Tick();
		If(Master)
		{
			Tracer=Master;
		}
		FaceTracer();
	}
	States
	{
	Spawn:
		NULL A 0 NoDelay/* {
		If(GetCVar("vid_renderer")>0 && TID!=0)
		{Return ResolveState("SpawnTrail");}
		Else If (GetCVar("vid_renderer")==0)
		{bFlatSprite=0;}
		Return ResolveState("Sprite");
		}
	Sprite:
		TNT1 A 0 A_JumpIf(GetCVar("vid_renderer")>0,"GLSprite");
		FAXE RSTUVWX 0 A_Jump(32,"SpawnTrail");
		Loop;
	GLSprite:
		P002 IJK 0 A_Jump(96,"SpawnTrail");
		Loop;*/;
	SpawnTrail:
		"----" A 0
		{
			If(TID!=0 && GetCVar("vid_renderer")>0)
			{
				Thing_ChangeTID(0,0);
				Roll=Pitch+90;
				Pitch=90;
				Angle+=90;
			}/*
			Else
			{
				If(GetCVar("vid_renderer")==0)
				{
				Scale.Y=Scale.X;
				}
				Else
				{
				Pitch*=-1;
				A_SpawnItemEx("LightningBeamTrailBase",flags:SXF_TRANSFERPITCH|1|SXF_TRANSFERSCALE|SXF_TRANSFERALPHA|SXF_TRANSFERRENDERSTYLE|SXF_TRANSFERSPRITEFRAME,0,1);
				}
			}*/
			Return ResolveState("Fade");
		}
	Fade:
		"----" A 1 A_JumpIf(Health==1,1);
		Stop;
		"----" A 1 { A_FadeOut(Speed); Scale.X+=specialf1;}
		Wait;
	}
}

Class HandleEquipment : EOA_Token {}
Class HookPoint : Actor
{
  default
  {
		Radius 52;
		Height 67;
		Monster;
		+NODAMAGE
		-PUFFONACTORS
		-ALWAYSPUFF
		+BLOODLESSIMPACT
		+NOGRAVITY
		+NOBLOCKMONST
		+NOPAIN
		+NOCLIP
		+NOBLOOD
		+NOTELEFRAG
		+DONTSQUASH
		+NORADIUSDMG
		+DONTTHRUST
		+NEVERTARGET
		+ISMONSTER
	}
  States
  {
  Spawn:
	HOOK A 1 Bright 
	{bISMONSTER = True;}
	Loop;
  CoolDown:
	HOOK B 75 Bright 
	{bISMONSTER = False;}
	GoTo Spawn;
  }
}

Class HookJoint: Actor
{
  default
  {
		Radius 10;
		Height 10;
	}
  States
  {
  Spawn:
	TNT1 A 1 Bright
	{
		A_CustomRailgun(0,5,"Tan","",RGF_SILENT,PuffType:"InvisiblePuff", Range:(Distance3D(Invoker.Tracer)/ 4),1 , 0.25, 1);
	}
	Stop;
  }
}

Class ForcePush : Actor
{
  default
  {
	  Radius 32;
	  Height 32;
	  Damage 65;
	  Projectile;
	  -PUFFONACTORS
	  -ALWAYSPUFF
	  +RANDOMIZE
	  //+RIPPER
	  +BLOODLESSIMPACT
	  +NOTELEPORT
	  +FORCERADIUSDMG
	  +CLIENTSIDEONLY
	}
	Override Int SpecialMissileHit(Actor Victim)
	{
		EOA_Weapon.FalterDemon(Victim);
		Return Super.SpecialMissileHit(Victim);
	}
  States
  {
  Spawn:
	TNT1 A 0;
	//TNT1 A 0 A_Explode(1,100,XF_NOSPLASH|XF_EXPLICITDAMAGETYPE,False,100,10,0,"none","none")
	TNT1 A 0 A_RadiusThrust(50,128,RTF_NOIMPACTDAMAGE,128);
	stop;
	Xdeath:
		TNT1 A 0
		{
			A_GiveToTarget("ShieldBashed", 1, AAPTR_DEFAULT);
		}
	stop;
  }
}

Class WeakForcePush : Actor
{
  default
  {
	  Radius 32;
	  Height 32;
	  Damage 6;
	  Projectile;
	  -PUFFONACTORS
	  -ALWAYSPUFF
	  +RANDOMIZE
	  //+RIPPER
	  +BLOODLESSIMPACT
	  +NOTELEPORT
	  +FORCERADIUSDMG
	  +CLIENTSIDEONLY
	}
  States
  {
  Spawn:
	TNT1 A 3;
	//TNT1 A 0 A_Explode(1,100,XF_NOSPLASH|XF_EXPLICITDAMAGETYPE,False,100,10,0,"none","none")
	TNT1 A 0 A_RadiusThrust(50,128,RTF_NOIMPACTDAMAGE,128);
	stop;
	Xdeath:
		TNT1 A 0;
	stop;
  }
}

Class BlankPuff : Actor
{
	Default
	{
		Height 0;
		VSpeed 0;
		+ALWAYSPUFF
		+NOGRAVITY
		+PUFFONACTORS
		+SKYEXPLODE
		+NOTIMEFREEZE
		+BLOODLESSIMPACT
		+NOTRIGGER
		+THRUACTORS
		+FORCEDECAL
		Decal "";
	}
	States
	{
	Spawn:
		TNT1 A 4;// NoDelay A_SpawnParticle("White",0,1,5);
		Stop;
	}
}
Class BlankPuffThruActors : BlankPuff { Default { +THRUACTORS +ALLOWTHRUFLAGS } }
Class BlankPuffNoAlways : BlankPuff { Default { -ALWAYSPUFF } }
Class BlankPuffNoAlwaysThruActors : BlankPuffNoAlways { Default { +THRUACTORS +ALLOWTHRUFLAGS } }


Class SwitchStyleDelay : EOA_Token { Default{Inventory.MaxAmount 10;} }

Class EOA_Weapon : DoomWeapon
{
	//Thank you, phantombeta! :D
	Transient CVar APR_Recoil;
	Private Int EOA_WeaponFlags;
	Flagdef PowerWeapon: EOA_WeaponFlags, 1;
	Flagdef SemiAuto: EOA_WeaponFlags, 2;
	Int MantleTics, MeleeTics, MeleeDelayTics, SpeedCounter, LedgeXVel;
	Int STics;
	Int EquipmentSwitchDelayTics;
	Bool SwitchEquipment;
	Double LedgeZStep, monkeyzpos;
	Bool MantleLedge, UseEquipment, SemiAutoOverride;
	Property MeleeTics: MeleeTics;
	ENum WeaponInfoFlags
	{
		WeapInfo_WeaponIcon = 0,
		WeapInfo_AmmoAmount = 1,
		WeapInfo_AmmoMaxAmount = 2,
		WeapInfo_AmmoWarnAmount = 3,
		WeapInfo_AmmoLowAmount = 4
	};
	ENum EOAWeaponReadyFlags //[DoomKrakken]: Custom flags for this special version of A_WeaponReady.
	{
		EOA_ALLOWMANTLE = 1, //Allows playing the animation for mantling ledges.
		EOA_ALLOWEQUIPMENT = 2, //Allows for usage of equipment.
		EOA_DISABLEHASTE = 4, //Disables speed boost from Haste.
		EOA_WEAPSPEEDUPGRADE = 8 //Allows for an additional speed boost (used in conjunction with the presence of a weapon speed upgrade).
	};
	Default
	{
		Inventory.PickupMessage "Congrats, you picked up something you shouldn't have.  Put it down, now.  Good boy. :)";
		Inventory.PickupSound "Item/Pickup";
		Weapon.AmmoType1 "None";
		Weapon.BobRangeX 0.3;
		Weapon.BobRangeY 0.1;
		Weapon.BobSpeed 2.5;
		Weapon.BobStyle "Inverse";
		EOA_Weapon.MeleeTics 12;
		+DONTGIB
		+INVENTORY.NOSCREENFLASH
		+INVENTORY.UNDROPPABLE
		+WEAPON.ALT_AMMO_OPTIONAL
		+WEAPON.NOALERT
		+WEAPON.NOAUTOAIM
	}
	Override Void MarkPrecacheSounds()
	{
		MarkSound("Weapon/Switch");
		MarkSound("Weapon/Loaded");
		MarkSound("Player/Mantle");
		MarkSound("Player/DoubleJump");
		MarkSound("Player/JumpThrust");
		MarkSound("Punch/Swing");
		MarkSound("QuadDamage/Shot");
		MarkSound("Frag/Pin");
		MarkSound("Hologram/Click");
		MarkSound("Rune/SeekAndDestroy");
		MarkSound("Rune/Savagery");
		MarkSound("Rune/ArmoredOffensive");
		MarkSound("Rune/BloodFueled");
		MarkSound("Rune/InFlightMobility");
		Super.MarkPrecacheSounds();
	}
	Action Void EOA_WeaponReady(Int Flags = 0, Int EOA_Flags = 0, Int SpeedRate = 3)
	{
		A_WeaponReady(Flags);
		Invoker.MantleLedge = (EOA_Flags & EOA_ALLOWMANTLE);
		Invoker.UseEquipment = (EOA_Flags & EOA_ALLOWEQUIPMENT);
		Bool Haste = (!(EOA_Flags & EOA_DISABLEHASTE)) && CountInv("PowerHaste");
		Bool Speed = (EOA_Flags & EOA_WEAPSPEEDUPGRADE);
		If (Haste || Speed)
		{
			If (Haste && Speed)
			{
				If (Invoker.SpeedCounter >= SpeedRate)
				{
					Invoker.SpeedCounter = 0;
				}
				Else
				{
					A_SetTics(0);
					Invoker.SpeedCounter++;
				}
			}
			Else If (Speed)
			{
				If (Invoker.SpeedCounter >= 4 - SpeedRate)
				{
					Invoker.SpeedCounter = 0;
				}
				Else
				{
					A_SetTics(0);
					Invoker.SpeedCounter++;
				}
			}
			Else If (Invoker.SpeedCounter)
			{
				A_SetTics(0);
				Invoker.SpeedCounter = 0;
			}
			Else
			{
				Invoker.SpeedCounter++;
			}
		}
	}
	Action Int GetSpeedCounter()
	{
		Return Invoker.SpeedCounter;
	}
	Action Void SetSpeedCounter(Int Amount)
	{
		Invoker.SpeedCounter = Amount;
	}
	Action Void EOA_CheckParry()
	{
		Double ClosestDist = Double.Infinity;
		PlayerInfo Player = Players[ConsolePlayer];
		//Double ClosestAng = CameraFOV / 2;
		Actor Victim;
		BlockThingsIterator It = BlockThingsIterator.Create(Invoker.Owner, 1024);
		While (It.Next())
		{
			Actor Mo = It.Thing;
			If (Mo && AbsAngle(AngleTo(Mo), Angle) <= CameraFOV / 2 && (Mo Is "DoomImpBall") && CheckSight(Mo) && CheckIfCloser(Mo, 500))
			//If (Mo && AbsAngle(AngleTo(Mo), Angle) <= CameraFOV / 2 && !Mo.bKILLED && Mo.bISMONSTER && Mo.bSHOOTABLE && !Mo.bDORMANT && CheckSight(Mo) && CheckIfCloser(Mo, 192 * (1 + CountInv("SeekAndDestroySelected")) * (1 + CountInv("SeekAndDestroySelected") * CountInv("SeekAndDestroyII"))) && !CountInv("RipAndTear") && !Mo.CountInv("GloryKillCounter") && (Mo.CountInv("PowerStaggered") || (CountInv("PowerBerserk") && (!Mo.bBOSS || Mo.Default.Health < 3000)) || (CountInv("EOA_InfiniteBerserkFist"))))
			{
				//Mo.A_FaceTarget(Player);
				Mo.Destroy();
				//Double Ang = AbsAngle(AngleTo(Mo), Angle);
				//If (Ang < ClosestAng)
				/*Double Dist = Distance3D(Mo);
				If (Dist < ClosestDist)
				{
					//ClosestAng = Ang;
					ClosestDist = Dist;
					Victim = Mo;
				}*/
			}
		}
		If (Victim)
		{
			Tracer = Victim; //Have the victim be stored in the player's Tracer pointer.
			A_GiveInventory("RipAndTear");
			Victim.A_GiveInventory("PowerStaggered");
			Victim.A_GiveInventory("GloryKillCounter");
			Victim.bNOTARGETSWITCH = True;
			Victim.bNEVERTARGET = True;
			Victim.bNODAMAGE = True;
		}
	}
	Action Void EOA_CheckGloryKill()
	{
		Double ClosestDist = Double.Infinity;
		//Double ClosestAng = CameraFOV / 2;
		Actor Victim;
		BlockThingsIterator It = BlockThingsIterator.Create(Invoker.Owner, 1024);
		While (It.Next())
		{
			Actor Mo = It.Thing;
			If (Mo && AbsAngle(AngleTo(Mo), Angle) <= CameraFOV / 2 && !Mo.bKILLED && Mo.bISMONSTER && Mo.bSHOOTABLE && !Mo.bDORMANT && CheckSight(Mo) && CheckIfCloser(Mo, 192 * (1 + CountInv("SeekAndDestroySelected")) * (1 + CountInv("SeekAndDestroySelected") * CountInv("SeekAndDestroyII"))) && !CountInv("RipAndTear") && !Mo.CountInv("GloryKillCounter") && (Mo.CountInv("PowerStaggered") || (CountInv("PowerBerserk") && (!Mo.bBOSS || Mo.Default.Health < 3000)) || (CountInv("EOA_InfiniteBerserkFist"))))
			{
				//Double Ang = AbsAngle(AngleTo(Mo), Angle);
				//If (Ang < ClosestAng)
				Double Dist = Distance3D(Mo);
				If (Dist < ClosestDist)
				{
					//ClosestAng = Ang;
					ClosestDist = Dist;
					Victim = Mo;
				}
			}
		}
		If (Victim)
		{
			Tracer = Victim; //Have the victim be stored in the player's Tracer pointer.
			A_GiveInventory("RipAndTear");
			Victim.A_GiveInventory("PowerStaggered");
			Victim.A_GiveInventory("GloryKillCounter");
			Victim.bNOTARGETSWITCH = True;
			Victim.bNEVERTARGET = True;
			Victim.bNODAMAGE = True;
		}
	}
	static Int HLExplode(actor self, actor inflictor, actor src, int damage=-1, int distance=-1, int flags=XF_HURTSOURCE,int fulldmgdist=0,name dmgtype='Nornmal')
	{
		if(!inflictor) inflictor=self;
		if(!src) src=self;
		int explodado=0;
		if(damage==-1) damage=self.ExplosionDamage;
		if(distance==-1) distance=self.ExplosionRadius;
		if(distance==-1) distance=self.ExplosionDamage; // if dist keeps giving -1, then use expdamage instead.
		Bool HurtSource=true;
		If(self.DontHurtShooter || !(flags & XF_HURTSOURCE)) HurtSource=False;
		for (let it = BlockThingsIterator.Create(self, distance); it.Next();)
		{
			Bool RadiusDmg=1;
			Bool DontHarmSpecies=1;
			If(self && it.thing)
			{
				RadiusDmg=self.bForceRadiusDmg || !it.thing.bNoRadiusDmg;
				DontHarmSpecies=it.thing.GetSpecies()==self.GetSpecies() && self.bDontHarmSpecies;
			}
			Bool Skip=False;
			actor src=self.target;
			if(flags && XF_NOTMISSILE) src=self;
			If(it.thing == src && !HurtSource) Skip=True;
			
			//src.a_log("hurtsource="..hurtsource.." src="..src.GetClassname().." ting="..it.thing.GetClassname().." skip="..skip);
			if (!skip && it.thing && self.Distance3D(it.thing)<=distance+it.thing.radius && self.CheckSight(it.thing) && RadiusDmg && !DontHarmSpecies && it.thing.health>0 && (it.thing.bShootable || it.thing.bVulnerable))
			{
				double dist=self.Distance3D(it.thing)-it.thing.radius-fulldmgdist;
				int dmg;
				If(dist<1)
				dmg=damage;
				Else
				{
					int antidist=int(distance-dist);
					//If(dist<=fulldmgdist) dmg=damage;
					//else
					dmg=damage*antidist/distance;
				}
				Vector3 OldVel=it.thing.Vel;
				double tcenter=it.thing.height/2;
				dmg=it.thing.DamageMobj(inflictor, src, dmg, dmgtype);
				If(!it.thing) Continue;
				Vector2 Dir=EOA_Weapon.FaceVector(self.pos,it.thing.pos+(0,0,tcenter));
				If(EOA_Weapon.CanBleed(it.thing) && dmg>0 && !self.bBloodLessImpact)
				{
					Double BDist=it.thing.Radius;
					Vector3 BPos=((Cos(Dir.X)*BDist)*Cos(-Dir.Y),(Sin(Dir.X)*BDist)*Cos(-Dir.Y),Sin(-Dir.Y)*BDist)+it.thing.Pos+(0,0,tcenter);
					it.thing.TraceBleedAngle(dmg,Dir.X+180,-Dir.Y);
					Double DS=Clamp(dmg/30,0.75,1.5);
					EOA_Weapon.SpawnBlood(it.thing,BPos,DS,false);
				}
				explodado++;
				it.thing.vel=OldVel;
				If(!it.thing.bDontThrust && !self.bNoDamageThrust)
				{
					Double Speed=dmg*25/it.thing.mass*-1;
					Vector3 Belu=((Cos(Dir.X)*Speed/2.)*Cos(-Dir.Y),(Sin(Dir.X)*Speed/2.)*Cos(-Dir.Y),Sin(-Dir.Y)*Speed);
					it.thing.vel+=Belu;
				}
				//self.a_Log("dmg: "..dmg);//.." dist3d: "..int(self.Distance3D(it.thing)).." dist: "..int(dist).." antidist: "..int(antidist).." fulldmgdist: "..fulldmgdist);
			}
		}
		Destructible.GeometryRadiusAttack(Self, inflictor, damage, distance, dmgtype, fulldmgdist); //idk if this works
		return explodado;
	}
	Action Double GetViewZ() //[DoomKrakken]: DO NOT NULLIFY!!!  If view-bobbing is enabled, projectiles will appear above or below the weapon's muzzle while the player is in motion.
	{
		Let Player = Invoker.Owner.Player;
		If (Player && Player.Mo && !CVar.FindCVar("EOA_ViewZ").GetBool())
		{
			Return Player.ViewZ - Player.Mo.Pos.Z - Player.ViewHeight;
		}
		Return 0;
	}
	Action Double GetRelVelY()
	{
		Let Player = Invoker.Owner.Player;
		If (Player && Player.Mo)
		{
			Return Vel.XY Dot AngleToVector(Angle - 90);
		}
		Return 0;
	}
	//LMBD Library
	static void AlignToSlope(Actor self, double dAng, double dPitch)
    {
        vector3 fNormal = self.CurSector.FloorPlane.Normal;
        vector2 fNormalP1 = (fNormal.X != 0 || fNormal.Y != 0) ? (fNormal.X, fNormal.Y).Unit() : (0, 0);
        vector2 fNormalP2 = ((fNormal.X, fNormal.Y).Length(), fNormal.Z);
        double fAng = atan2(fNormalP1.Y, fNormalP1.X); // floor angle (not pitch!)
        double fPitch = -atan2(fNormalP2.X, fNormalP2.Y); // floor pitch
        double dDiff1 = sin(fAng - (dAng + dPitch));
        double dDiff2 = cos(fAng - dAng);
        self.A_SetPitch(fPitch * dDiff2 + dPitch);
        self.A_SetRoll(fPitch * dDiff1);
        self.angle = atan2(fnormalp1.y, fnormalp1.x);
        //self.Angle=dAng;
    }
	static vector2 FaceVector(vector3 source, vector3 dest)
	{

		double xx=source.x - dest.x;
		double yy=source.y - dest.y;
		double zz=source.z - dest.z;
		double a=VectorAngle(xx,yy);
		double p=-VectorAngle(sqrt((xx*xx)+(yy*yy)),zz);
		Return (a,p);
	}
	static double VectorLength(vector3 source, vector3 dest, bool usez=true)
	{
		If(usez)
		Return sqrt(
		(source.x - dest.x) * (source.x - dest.x) +
		(source.y - dest.y) * (source.y - dest.y) +
		(source.z - dest.z) * (source.z - dest.z));
		Return sqrt(
		(source.x - dest.x) * (source.x - dest.x) +
		(source.y - dest.y) * (source.y - dest.y));
	}
	static bool CanBleed(Actor Self)
	{
		if(Self.bNoBlood || Self.bInvulnerable || (Self.bDormant && Self.bIsMonster) || GetDefaultByType(Self.GetBloodType(0)).bNoBlood)
		Return False;
		Return True;
	}
	
	static Actor SpawnBlood(Actor Self, Vector3 Pos, Double Scale=1.0, bool CheckBleed=True, Int BloodType=0)
	{
		Bool Bleed=True;
		If(CheckBleed) Bleed=CanBleed(Self);
		If(Self && Bleed)
		{
			Actor Blod=Spawn(Self.GetBloodType(BloodType),Pos,ALLOW_REPLACE);
			If(Blod)
			{
				Blod.Translation=Self.BloodTranslation;
			}
			Return Blod;
		}
		Return Null;
	}
	
	static void FlipSprite(Bool Flip)
	{
		PlayerInfo Player = Players[ConsolePlayer];
		/*If (Player && Player.Mo && Player.Mo == Owner && Player.ReadyWeapon == Self && Player.FindPSprite(PSP_WEAPON) && !Player.Mo.CountInv("RipAndTear"))
		{
			Player.FindPSprite(PSP_WEAPON).
		}*/
		let plr = player;
		let wep = plr.FindPSprite(PSP_WEAPON);
		let pspr = plr.psprites;
		Player.FindPSprite(PSP_WEAPON).bFlip = Player.FindPSprite(PSP_WEAPON).bMirror = Flip;
	}
	
	static void A_SpawnActorLine(string classname, Vector3 pointA, Vector3 pointB, double units = 1)
	{
		// get a vector pointing from A to B
		let pointAB = pointB - pointA;

		// get distance
		let dist = pointAB.Length();

		// normalize it
		pointAB /= dist == 0 ? 1 : dist;

		// iterate in units of 'units'
		for (double i = 0; i < dist; i += units)
		{
			// we can now use 'pointA + i * pointAB' to
			// get a position that is 'i' units away from
			// pointA, heading in the direction towards pointB
			let position = pointA + i * pointAB;
			Spawn(classname, position);
		}
	}
	static bool CheckState(Actor Self, StateLabel st)
	{
		If(Self.FindState(st,1) && Self.InStateSequence(Self.CurState,Self.ResolveState(st)))
		Return True;
		Return False;
	}
	static state ChangeState(Actor Self,StateLabel st, Bool Force=False)
	{
		If(CheckState(Self,st)) Return Null;
		Else If(Self.FindState(st))
		{
			If(Force)
			Self.SetStateLabel(st);
			Return Self.ResolveState(st);
		}
		Return Null;
	}
	static bool RandomChance(Int Chance, Int MaxChance=256)
	{
		If(Random(0,MaxChance)<=Chance)
		Return True;
		Return False;
	}
	static Bool V3InFOV(Vector3 Source, Vector3 Dest, Vector2 SrcDir, Vector2 FOV)
	{
		Vector2 Dir=FaceVector(Dest,Source);
		If(abs(deltaangle(SrcDir.X,Dir.X))<=Fov.X && abs(deltaangle(SrcDir.Y,Dir.Y))<=FOV.Y)
		Return True;
		Return False;
	}
	Static Vector3 RotatedVec(Vector3 Offs=(0,0,0), Double Angle=0,Double Pitch=0,Double Roll=0)
	{
		/*Double Extra=(Offs.X*0.5)*Cos(Pitch);
		Offs.X+=Extra;
		Offs.Y*=0.5;*/
		
		Vector2 SSS=RotateVector((Offs.Y,Offs.Z),Roll);
		Offs.Y=SSS.X;
		Offs.Z=SSS.Y;
		Vector2 R=RotateVector((Offs.X*Cos(-Pitch) + Sin(Pitch)*Offs.Z,Offs.Y),Angle);
		Vector3 SpawnOffs=(R,Offs.Z*Cos(Pitch)  +  Offs.X*Sin(-Pitch));
		Return SpawnOffs;
	}
	static Vector3 Vec3ToDir(Double Speed, Double Angle, Double Pitch)
	{
		Return (
		(Cos(Angle)*Speed)*Cos(Pitch),
		(Sin(Angle)*Speed)*Cos(Pitch),
		Sin(-Pitch)*Speed);
	}
	
	Void SpawnBeam(Vector3 StartPos, Vector3 EndPos)
	{
		Double Speed=64;
		Double Travel;
		If(Owner.GetCVar("EOAE_CenteredWeapons"))
		{
			StartPos = (StartPos.X - 6, StartPos.Y, StartPos.Z);
		}
		Vector3 CurPos=StartPos;
		Vector2 Dir=EOA_Weapon.FaceVector(EndPos,StartPos);
		Vector3 MoveDir=EOA_Weapon.RotatedVec((Speed,0,0),Dir.X,Dir.Y,0);
		Double Dist=Abs(Level.Vec3Diff(EndPos,CurPos).Length());
		Int Count;
		Actor LastBeam;
		Actor LastBeam2;
		While(Travel<5000)
		{
			Double CurDist=Abs(Level.Vec3Diff(EndPos,CurPos).Length());
			
			Vector3 RandOffs=(0,Frandom(-3,3),Frandom(-3,3));
			
			Vector3 Offset;
			Offset=EOA_Weapon.RotatedVec(Offset,Dir.X,Dir.Y,0);
			
			Double coso=CurDist/Dist;
			Offset*=Sin(180*coso);
			
			If(1)//count%4==0)
			{
					Actor P=Actor.Spawn("LightningBeamTrailBase1",CurPos+Offset);
					P.A_SetRenderStyle(0.99,STYLE_ADDSHADED);
					P.SetShade("ff1010");
					P.Health=1;
					P.SpecialF1=0.4;
					P.Speed=0.05;
					P.Vel3DFromAngle(5.0,Dir.X,Dir.Y);
					P.bBright=True;
					If(LastBeam && P)
					{
						Vector2 Dir=EOA_Weapon.FaceVector(LastBeam.Pos,P.Pos);
						LastBeam.Angle=Dir.X;
						LastBeam.Pitch=-Dir.Y+90;
						Double BDist=(LastBeam.Pos-P.Pos).Length();
						LastBeam.Scale.Y/=32/BDist;
						LastBeam.Scale.X=15;
						LastBeam.Master=P;
						P.Vel=EOA_Weapon.RotatedVec((-0.5,FRandom(-0.25,0.25),FRandom(-0.25,0.25)),Dir.X,Dir.Y);
						//P.Vel=LMBDLib.RotatedVec((-0.5,0,0),Dir.X,Dir.Y);
					}
					LastBeam=P;
					
					//inner beam
					Actor P2=Actor.Spawn("LightningBeamTrailBase1",CurPos+Offset);
					P2.A_SetRenderStyle(0.99,STYLE_ADDSHADED);
					P2.SetShade("ff8020");
					P2.Health=1;
					P2.SpecialF1=0.4;
					P2.Speed=0.05;
					P2.Vel3DFromAngle(5.0,Dir.X,Dir.Y);
					P2.bBright=True;
					If(LastBeam2 && P2)
					{
						Vector2 Dir=EOA_Weapon.FaceVector(LastBeam2.Pos,P2.Pos);
						LastBeam2.Angle=Dir.X;
						LastBeam2.Pitch=-Dir.Y+90;
						Double BDist2=(LastBeam2.Pos-P2.Pos).Length();
						LastBeam2.Scale.Y/=32/BDist2;
						LastBeam2.Scale.X=8;
						LastBeam2.Master=P2;
						P2.Vel=EOA_Weapon.RotatedVec((-0.5,FRandom(-0.25,0.25),FRandom(-0.25,0.25)),Dir.X,Dir.Y);
						//P.Vel=LMBDLib.RotatedVec((-0.5,0,0),Dir.X,Dir.Y);
					}
					LastBeam2=P2;
			}
			Count++;
			Travel+=Speed;
			CurPos+=MoveDir;
			
			If(CurDist<=Speed)
			{
				
				Vector2 Dir=EOA_Weapon.FaceVector(LastBeam.Pos,EndPos);
				LastBeam.Angle=Dir.X;
				LastBeam.Pitch=-Dir.Y+90;
				Double BDist=(LastBeam.Pos-EndPos).Length();
				LastBeam.Scale.Y/=64/BDist;
				LastBeam.Scale.X=8;
				
				Vector2 Dir2=EOA_Weapon.FaceVector(LastBeam2.Pos,EndPos);
				LastBeam2.Angle=Dir2.X;
				LastBeam2.Pitch=-Dir2.Y+90;
				Double BDist2=(LastBeam2.Pos-EndPos).Length();
				LastBeam2.Scale.Y/=64/BDist2;
				LastBeam2.Scale.X=8;

				Return;
			} 
		}
	}
	//EOA Library
	Static Vector3 GetLedgeOffset(Actor Activator)
	{
		PlayerInfo Player = Activator.Player;
		Bool PlayerOnGround = Player && Player.Mo && Player.Mo == Activator && Player.OnGround;
		Vector3 OldPos = Activator.Pos;
		Vector3 Highest = (0, 0, 0); //[DoomKrakken]: Returns the highest height to mantle, so that the mantling doesn't get stuck.
		Int MaxHeight = 72 / (1 + PlayerOnGround); //[DoomKrakken]: The maximum height to check for mantling.  Mantling while not in the air will result in a shorter check, since the Slayer can auto-mantle shorter ledges, but must be midair in order to mantle taller ledges.
		Int i; //[DoomKrakken]: Radius Check
		For (i = 0; i <= Activator.Radius; i++) //[DoomKrakken]: Let's have some elbow room.
		{
			For (Int j = 0; j <= 315; j += 45)
			{
				If (Activator.GetZAt(i, 0, j, GZF_NO3DFLOOR|GZF_CEILING) - Activator.GetZAt(i, 0, j, GZF_3DRESTRICT|GZF_CEILING)) //[DoomKrakken]: This check is only necessary for 3D floors.  Therefore, check if we're dealing with a 3D floor to begin with (we will if the difference is non-zero).
				{
					If (Activator.GetZAt(i, 0, j, GZF_3DRESTRICT|GZF_CEILING) - OldPos.Z < Activator.Height + MaxHeight) //[DoomKrakken]: Check to see if any point in front of, behind, or to either side of the player has too low of a ceiling or is in the level.
					{
						Return (0, 0, 0);
					}
				}
			}
		}
		Activator.SetXYZ(OldPos + (0, 0, MaxHeight)); //[DoomKrakken]: Use SetXYZ to change the actor's position for testing purposes, without actually moving him.  This way he can detect 3D floors using GetZAt (since it can only be used to detect 3D floors beneath the player).
		For (i = Activator.Radius; i <= Activator.Radius * 2; i++) //[DoomKrakken]: If attempting to mantle at an angle to the ledge, the check may fall short and yield a negative result.  This'll make sure that it won't happen.
		{
			Vector3 np = Activator.Vec3Angle(i, Activator.Angle, 0);
			Int LedgeFloorZ = Activator.GetZAt(i, 0, 0);
			Int LedgeCeilingZ = Activator.GetZAt(i, 0, 0, GZF_CEILING);
			If (LedgeFloorZ - OldPos.Z > Activator.MaxStepHeight && LedgeFloorZ - OldPos.Z <= MaxHeight && LedgeCeilingZ - LedgeFloorZ >= Activator.Height && Activator.CheckPosition(np.XY))
			{
				If (Highest.Z < min(LedgeFloorZ - OldPos.Z, Activator.Height)) //[DoomKrakken]: Find the highest ledge.
				{
					Highest = (i, 0, min(LedgeFloorZ - OldPos.Z, Activator.Height));
				}
			}
		}
		Activator.SetXYZ(OldPos);
		Return Highest;
	}
	Static String GetWeaponIcon(Actor Activator)
	{
		If (!Activator || !Activator.Player || !Activator.Player.ReadyWeapon)
		{
			Return "";
		}
		Let Player = Activator.Player;
		Let Icon = TexMan.GetName(Activator.Player.ReadyWeapon.Icon);
		If (Icon)
		{
			Return Icon;
		}
		Return "TNT1A0";
	}
	Static String GetWeaponAmmoType(Actor Activator)
	{
		If (!Activator || !Activator.Player || !Activator.Player.ReadyWeapon)
		{
			Return "";
		}
		Let Player = Activator.Player;
		Let AmmoType = Player.ReadyWeapon.AmmoType1;
		Let Item = Activator.FindInventory(AmmoType);
		If (Item)
		{
			Return Item.GetClassName();
		}
		Return "None";
	}
	Static Int GetWeaponAmmoInfo(Actor Activator, Int WeaponInfo = 0)
	{
		If (!Activator || !Activator.Player || !Activator.Player.ReadyWeapon)
		{
			Return 0;
		}
		Let Player = Activator.Player;
		Let AmmoType = Player.ReadyWeapon.AmmoType1;
		Let Item = Activator.FindInventory(AmmoType);
		If (Item)
		{
			Switch(WeaponInfo)
			{
				Case 1:
					Return Activator.CountInv(AmmoType);
				Case 2:
					Return Item.MaxAmount;
				Case 3:
					Return EOA_Ammo(Item) ? EOA_Ammo(Item).WarnAmount : 0;
				Case 4:
					Return EOA_Ammo(Item) ? EOA_Ammo(Item).LowAmount : 0;
			}
		}
		Return 0;
	}
	Action Void EOA_FireBullets(Double Spread_XY, Double Spread_Z, Int NumBullets, Int DamagePerBullet, Class<Actor> PuffType = "BulletPuff", Int Flags = 1, Double Range = 0, Class<Actor> Missile = Null, Double SpawnHeight = 0, Double SpawnOfs_XY = 0, Double PitchCompOfs = 10) //[DoomKrakken]: We're not doing 32 for SpawnHeight.  That's uber retarded.
	{
		Let Player = Player;
		If (!Player)
		{
			Return;
		}
		Let Pawn = PlayerPawn(Self);
		Let Weapon = Player.ReadyWeapon;

		Int i;
		Double bangle;
		Double bslope = 0.;
		Int LAFlags = (Flags & FBF_NORANDOMPUFFZ)? LAF_NORANDOMPUFFZ : 0;
		If(GetCVar("EOAE_CenteredWeapons"))
		{
			SpawnOfs_XY = GetRelVelY() / 3;
		}
		If ((Flags & FBF_USEAMMO) && Weapon && StateInfo != Null && StateInfo.mStateType == STATE_PSprite)
		{
			If (!Weapon.DepleteAmmo(Weapon.bALTFIRE, True))
			{
				Return;	// out of ammo
			}
		}
		
		If (Range == 0)	Range = PLAYERMISSILERANGE;

		If (!(Flags & FBF_NOFLASH))
		{
			Pawn.PlayAttacking2();
		}

		If (!(Flags & FBF_NOPITCH))
		{
			bslope = BulletSlope();
		}
		bangle = Angle;

		If (PuffType == Null) PuffType = 'BulletPuff';

		If (Weapon != Null)
		{
			A_StartSound(Weapon.AttackSound, CHAN_WEAPON);
		}

		If ((NumBullets == 1 && !Player.ReFire) || NumBullets == 0)
		{
			Int Damage = DamagePerBullet;

			If (!(Flags & FBF_NORANDOM))
			{
				Damage *= Random[CABullet](1, 3);
			}
			Let ProjSpawner = LineAttack(Angle, Radius * 2 * cos(Pitch), Pitch, 0, 'Hitscan', "EOA_NullPuff", LAFlags);
			If (ProjSpawner)
			{
				Let Player = Self.Player;
				ProjSpawner.A_SetSize(0.5, 1);
				Let Puff = ProjSpawner.LineAttack(bangle, Range, bslope, Damage, 'Hitscan', PuffType, LAFlags, OffsetZ: -8);
				If (Puff && ProjSpawner.CheckIfCloser(Puff, Radius * 2))
				{
					ProjSpawner.SetOrigin((Pos.X, Pos.Y, ProjSpawner.Pos.Z), False);
				}
				If (Missile != Null)
				{
					Bool Temp = False;
					Double Ang = Angle - 90;
					Vector2 Ofs = AngleToVector(Ang, SpawnOfs_XY);
					//[DoomKrakken]: Thank you, Marisa Kirisame!
					Vector3 x, y, z;
					[x, y, z] = CoordUtil.GetAxes(Pitch, Angle, Roll);
					Actor Proj = ProjSpawner.SpawnMissileXYZ(Level.Vec3Offset(ProjSpawner.Pos, (Ofs.X, Ofs.Y, SpawnHeight) - (PitchCompOfs * sin(abs(Pitch))) * z), Puff, Missile, True, Self);
					If (Proj)
					{
						Proj.Angle = bangle;
						Proj.Pitch = Pitch;
						Proj.Target = Self;
						Proj.SetFriendPlayer(Self.Player);
						If (!Puff)
						{
							Temp = True;
							Puff = ProjSpawner.LineAttack(bangle, Range, bslope, 0, 'Hitscan', PuffType, LAFlags|LAF_NOINTERACT, OffsetZ: -8);
						}
						AimBulletMissile(Proj, Puff, Flags, Temp, False);
					}
				}
			}
		}
		Else 
		{
			For (i = 0; i < abs(NumBullets); i++)
			{
				Double pangle = bangle;
				Double slope = bslope;

				If (Flags & FBF_EXPLICITANGLE)
				{
					pangle += spread_xy;
					slope += spread_z;
				}
				Else
				{
					pangle += spread_xy * Random2[cabullet]() / 255.;
					slope += spread_z * Random2[cabullet]() / 255.;
				}

				Int Damage = DamagePerBullet;

				If (!(Flags & FBF_NORANDOM))
				{
					Damage *= random[CABullet](1, 3);
				}
				Let ProjSpawner = LineAttack(Angle, Radius * 2 * cos(Pitch), Pitch, 0, 'Hitscan', "EOA_NullPuff", LAFlags);
				If (ProjSpawner)
				{
					ProjSpawner.A_SetSize(0.5, 1);
					Let Puff = ProjSpawner.LineAttack(pangle, Range, Slope, Damage, 'Hitscan', PuffType, LAFlags, OffsetZ: -8);
					If (Puff && ProjSpawner.CheckIfCloser(Puff, Radius * 2))
					{
						ProjSpawner.SetOrigin((Pos.X, Pos.Y, ProjSpawner.Pos.Z), False);
					}
					If (Missile != Null)
					{
						Bool Temp = False;
						Double Ang = Angle - 90;
						Vector2 Ofs = AngleToVector(Ang, SpawnOfs_XY);
						Vector3 x, y, z;
						[x, y, z] = CoordUtil.GetAxes(Pitch, Angle, Roll);
						Actor Proj = ProjSpawner.SpawnMissileXYZ(Level.Vec3Offset(ProjSpawner.Pos, (Ofs.X, Ofs.Y, SpawnHeight) - (PitchCompOfs * sin(abs(Pitch))) * z), Puff, Missile, True, Self);
						If (Proj)
						{
							Proj.Angle = bangle;
							Proj.Pitch = Pitch;
							Proj.Target = Self;
							Proj.SetFriendPlayer(Self.Player);
							If (!Puff)
							{
								Temp = True;
								Puff = ProjSpawner.LineAttack(bangle, Range, bslope, 0, 'Hitscan', PuffType, LAFlags|LAF_NOINTERACT, OffsetZ: -8);
							}
							AimBulletMissile(Proj, Puff, Flags, Temp, False);
						}
					}
				}
			}
		}
	}
	Action Void EOA_SetWeaponRecoilOffset(Double OfsAngle = 0, Double OfsPitch = 0, Double OfsRoll = 0, Double Factor = 1.0, Bool Interpolate = True)
	{
		Invoker.APR_Recoil = Invoker.APR_Recoil ? Invoker.APR_Recoil : CVar.GetCVar("EOA_APRRecoil", Self.Player);
		If (Invoker.APR_Recoil.GetBool())
		{
			Let RecoilHandler = New("EOA_WeaponRecoilThinker");
			If (RecoilHandler)
			{
				RecoilHandler.Owner = Self;
				RecoilHandler.RecoilAngle = OfsAngle;
				RecoilHandler.RecoilPitch = OfsPitch;
				RecoilHandler.RecoilRoll = OfsRoll;
				RecoilHandler.RecoilFactor = abs(Factor);
				If (RecoilHandler.RecoilFactor == 0)
				{
					RecoilHandler.RecoilFactor = 1;
				}
				A_SetAngle(Angle + OfsAngle, Interpolate);
				A_SetPitch(Pitch + OfsPitch, Interpolate);
				A_SetRoll(Roll + OfsRoll, Interpolate);
			}
		}
	}
	Action Void EOA_SetGKRecoilOffset(Double OfsAngle = 0, Double OfsPitch = 0, Double OfsRoll = 0, Bool Ignore = False, Bool Interpolate = True)
	{
		Invoker.APR_Recoil = Invoker.APR_Recoil ? Invoker.APR_Recoil : CVar.GetCVar("EOA_APRRecoil", Self.Player);
		If (Invoker.APR_Recoil.GetBool())
		{
			Let RecoilHandler = New("EOA_GKRecoilThinker");
			If (RecoilHandler)
			{
				RecoilHandler.Owner = Self;
				RecoilHandler.RecoilAngle = OfsAngle;
				RecoilHandler.RecoilPitch = OfsPitch;
				RecoilHandler.RecoilRoll = OfsRoll;
				RecoilHandler.RecoilFactor = 0.5;
				RecoilHandler.Ignore = Ignore;
				A_SetAngle(Angle + OfsAngle, Interpolate);
				A_SetPitch(Pitch + OfsPitch, Interpolate);
				A_SetRoll(Roll + OfsRoll, Interpolate);
			}
		}
	}
	Action Bool CheckSemiAuto()
	{
		Return Invoker.bSEMIAUTO;
	}
	Action Bool CheckWeaponClass(Class<Weapon> Weap)
	{
		Return Weap && Invoker Is Weap;
	}
	Action Bool EOA_CheckMeleeDelay()
	{
		If (Invoker Is "EOA_SuperShotgun" && !CountInv("SSGShots"))
		{
			Return True;
		}
		Return Invoker.MeleeDelayTics;
	}
	Action Void EOA_SetMeleeDelay()
	{
		Invoker.MeleeDelayTics = Invoker.Default.MeleeTics;
	}
	Action Void EOA_MeleeDash()
	{
		FTranslatedLineTarget LTarget;
		Let Puff = LineAttack(Angle, 256, Pitch, 0, "None", "EOA_NullPuff2", LAF_NORANDOMPUFFZ|LAF_NOIMPACTDECAL, LTarget);
		If (Puff)
		{
			Puff.Destroy();
		}
		If (LTarget.LineTarget)
		{
			Let Victim = LTarget.LineTarget;
			If ((Victim.bISMONSTER || Victim Is "EOA_WeakPoint") && abs(Victim.Pos.Z - Pos.Z) <= (Height + 25) && ((Pos.Z <= (FloorZ + 25)) || bONMOBJ))
			{
				Let MT = New("EOA_MeleeThinker");
				If (MT)
				{
					MT.Owner = Self;
					MT.Victim = Victim;
				}
			}
		}
	}
	/*Action Void CheckSwim()
	{
		PlayerInfo Player = Owner.Player;
		If (WaterLevel == 3)
		{
			Player.Mo.A_TakeInventory("TacticalScopeSelected");
		}
	}*/
	
	Override Void DoEffect()
	{
		/*string v = "bruh";
		for (int i = 0; i < v.length(); i++) {
			If(i < v.length())
			{Console.Printf(v.CharAt(i));}
		}*/
		PlayerInfo Player = Owner.Player;
		If (Player && Player.Mo && Player.Mo == Owner && Player.ReadyWeapon == Self && Player.FindPSprite(PSP_WEAPON) && !Player.Mo.CountInv("RipAndTear"))
		{	
			/*If (Player.Mo.WaterLevel == 3)
			{
				//Player.Mo.A_TakeInventory("TacticalScopeSelected");
				Player.Mo.A_GiveInventory("EOA_SwimmingArms");
				Player.Mo.A_SelectWeapon("EOA_SwimmingArms");
			}*/
			/*Let CurAmmoType = Player.ReadyWeapon.AmmoType1;
			If(!Owner.InStateSequence(CurState, ResolveState("Select")))
			{
				If(!Owner.CountInv(CurAmmoType))
				{
					Player.Mo.A_WeaponOffset(-25, 30, WOF_ADD|WOF_INTERPOLATE);
					/*Player.FindPSprite(PSP_WEAPON).x -= 25; 
					Player.FindPSprite(PSP_WEAPON).y += 20;
					Player.FindPSprite(PSP_WEAPON).Rotation = 10;
				}
				Else
				{
					A_WeaponOffset();
					//Player.FindPSprite(PSP_WEAPON).x = 0; 
					//Player.FindPSprite(PSP_WEAPON).y = 0;
					Player.FindPSprite(PSP_WEAPON).Rotation = 0;
				}
			}*/
			EOA_Token.SetMaxInventory(Owner, "CrucibleAmmo", 2 * (1 + Owner.CountInv("ArmoredOffensiveSelected")));
			Vector3 LedgeOffset = GetLedgeOffset(Owner); //[DoomKrakken]: This function returns the distance away from the ledge (X) and height from the actor's feet (Z) in the form of a Vector3.  Y remains untouched.
			If (LedgeOffset.Z > 0 && !Owner.CountInv("Grabbing_A_Ledge") && (Owner.GetPlayerInput(INPUT_BUTTONS) & BT_FORWARD) && !(Owner.GetPlayerInput(INPUT_BUTTONS) & BT_CROUCH) && !Owner.CountInv("EOA_MantleCooldown")) //[DoomKrakken]: Most of the necessary checks were put into GetLedgeOffset.  If it successfully found a ledge to mantle, it will return a number greater than 0 for both LedgeOffset.X and LedgeOffset.Z, so checking for either of those being greater than 0 will be enough to tell us whether or not to go through with this movement.
			{
				Owner.A_GiveInventory("Grabbing_A_Ledge"); //[DoomKrakken]: The necessary counter which just about everything else relies on in order to jump to the necessary animation.
				LedgeZStep = LedgeOffset.Z / 10.0 * (1 + Owner.CountInv("QuickHands")); //[DoomKrakken]: Divide the offset height of the ledge into individual steps.
				MantleTics = 10 / (1 + Owner.CountInv("QuickHands")); //[DoomKrakken]: Define the number of tics to spend mantling.
			}
			If (Owner.CountInv("Grabbing_A_Ledge") && !Owner.CountInv("HammerSmashing"))
			{
				If (MantleLedge)
				{
					Player.FindPSprite(PSP_WEAPON).SetState(ResolveState("LedgeClimb")); //[DoomKrakken]: This finds the "LedgeClimb" state sequence in the weapon PSprites (HUD-view sprites) for the player that "owns" them and then jumps to it.  DoEffect works outside of the direct PSprite state manipulation, so any "jumps" that would occur here in the function need to be done this way.
				}
			}
			If(Owner.CountInv("DEHellBreakerSmash"))
			{
				Player.FindPSprite(PSP_WEAPON).SetState(ResolveState("HammerSmash"));
			}
			If(Owner.CountInv("DoTheClimb"))
			{
				Player.FindPSprite(PSP_WEAPON).SetState(ResolveState("WallClimb"));
			}
			If (Owner.CountInv("ClimbHand") && !Owner.CountInv("HammerSmashing"))
			{
				DoomSlayer MoPlayer = DoomSlayer(Owner);
				monkeyzpos = MoPlayer.monkeypole.pos.z;
				Player.FindPSprite(PSP_WEAPON).SetState(ResolveState("MonkeyPole")); 
				Owner.A_GiveInventory("DoubleJumpCounter");
			}
			Vector3 OldPos = Owner.Pos; //[DoomKrakken]: Store the old position of the player...
			Owner.SetXYZ(OldPos + (0, 0, 72 / (1 + Player.OnGround))); //[DoomKrakken]: ... and then set his XYZ so that 3D floors above him can be detected.
			If (MantleTics > 0 && OldPos.Z < Owner.GetZAt(LedgeOffset.X, 0, 0) + Player.Mo.MaxStepHeight) //[DoomKrakken]: Do this while we still have MantleTics and the player's actual position is still below the desired ledge.
			{
				Owner.SetXYZ(OldPos); //[DoomKrakken]: Reset the XYZ back to its original position.
				MantleTics--; //Decrement MantleTics.
				Player.Cheats |= CF_TOTALLYFROZEN; //Freeze the player so that he can't interfere with the movement.
				Owner.A_SetGravity(0); //No falling. :D
				Owner.A_ChangeVelocity(max(0.5, LedgeOffset.X - Owner.Radius) / 1.5, 0, 0, CVF_RELATIVE|CVF_REPLACE); //Move forward.
				Owner.SetOrigin(OldPos + (0, 0, LedgeZStep), True); //Move up.
			}
			Else
			{
				Owner.SetXYZ(OldPos); //[DoomKrakken]: Reset the XYZ back to its original position.
				MantleTics = 0; //[DoomKrakken]: Reset MantleTics.
				If (!(Self Is "EOA_InteractWeapon") && !(Owner.CountInv("RipAndTear") || Owner.CountInv("ChainsawRipAndTear")))
				{
					Player.Cheats &= ~CF_TOTALLYFROZEN; //[DoomKrakken]: Unfreeze the player.
				}
				Owner.A_TakeInventory("Grabbing_A_Ledge"); //[DoomKrakken]: Take the mantling counter.
				Owner.A_SetGravity(Owner.Default.Gravity); //[DoomKrakken]: Restore the player's gravity.
				//SwitchEquipment
			}
			If(!Owner.CountInv("EquipmentTrigger"))
			{
				SwitchEquipment = True;
			}
			If (SwitchEquipment && Owner.CountInv("EquipmentTrigger"))
			{
				SwitchEquipment = False;
				If(!Owner.Countinv("grenadeSelected") && Owner.CountInv("FragGrenade") && Owner.CountInv("IceBomb"))
				{
					Owner.A_giveinventory("grenadeselected",1);
					EOA_SpawnNoiseMaker("FragSelected");
				}
				Else If(Owner.Countinv("grenadeselected") && Owner.CountInv("FragGrenade") && Owner.CountInv("IceBomb"))
				{
					Owner.A_takeinventory("grenadeselected",1);
					EOA_SpawnNoiseMaker("IceBombSelected");
				}
			}
			/*If (EquipmentSwitchDelayTics <= 0 && Owner.CountInv("EquipmentTrigger"))
			{
				EquipmentSwitchDelayTics += 10;
				If(!Owner.Countinv("grenadeSelected") && Owner.CountInv("FragGrenade") && Owner.CountInv("IceBomb"))
				{
					Owner.A_giveinventory("grenadeselected",1);
					A_PlaySound("FragSelected",1,1.0);
				}
				Else If(Owner.Countinv("grenadeselected") && Owner.CountInv("FragGrenade") && Owner.CountInv("IceBomb"))
				{
					Owner.A_takeinventory("grenadeselected",1);
					A_PlaySound("IceBombSelected",1,1.0);
				}
			}*/
			If (EquipmentSwitchDelayTics >= 1)
			{
				EquipmentSwitchDelayTics -= 1;
			}
			Else If (EquipmentSwitchDelayTics <= 0)
			{
				EquipmentSwitchDelayTics == 0;
			}
		}
		MantleLedge = False;
		MeleeDelayTics -= 1 + (Self Is "EOA_SuperShotgun" && Owner.CountInv("FasterReload")); //[DoomKrakken]: Faster cooldown for the primary fire of the Super Shotgun if Faster Reload is here.
		MeleeDelayTics = max(0, MeleeDelayTics);
		If (!Owner.CountInv("Dexterity"))
		{
			If (Owner.CountInv("EOA_HAPistol") + Owner.CountInv("EOA_CombatShotgun") + Owner.CountInv("EOA_SuperShotgun") + Owner.CountInv("EOA_HeavyAssaultRifle") + Owner.CountInv("EOA_RocketLauncher") + Owner.CountInv("EOA_PlasmaRifle") + Owner.CountInv("EOA_GaussCannon") + Owner.CountInv("EOA_Chaingun") >= 1)
			{
				Owner.A_GiveInventory("Dexterity");
			}
		}
		Super.DoEffect();
	}
	Action Int GetFrame()
	{
		PlayerInfo Player = Players[ConsolePlayer];
		If (Player && Player.Mo && Player.Mo == Invoker.Owner && Invoker.Owner && Player.ReadyWeapon == Invoker && Player.FindPSprite(PSP_WEAPON))
		{
			Return Player.FindPSprite(PSP_WEAPON).Frame;
		}
		Return -1;
	}
	Action Bool CheckGKVictimState(StateLabel Label = "XDeath")
	{
		PlayerInfo Player = Players[ConsolePlayer];
		Let ThisPlayer = DoomSlayer(Player.Mo);
		If (Tracer && ThisPlayer)
		{
			Return Tracer.FindState(Label);
		}
		Return False;
	}
	Action Int GetGKAngle() //Calculates difference in angle between inflictor and victim.
	{
		PlayerInfo Player = Players[ConsolePlayer];
		Let ThisPlayer = DoomSlayer(Player.Mo);
		If (Tracer && ThisPlayer)
		{
			Int Ret;
			Int VictimAngle = Int(DeltaAngle(Tracer.AngleTo(Self), Tracer.Angle));
			If ((-22.5 < VictimAngle && VictimAngle < 22.5)) //Front
			{
				Ret = 0;
			}
			Else If (22.5 <= VictimAngle && VictimAngle < 67.5) //Front Right
			{
				Ret = 1;
			}
			Else If (67.5 <= VictimAngle && VictimAngle < 112.5) //Right
			{
				Ret = 2;
			}
			Else If (112.5 <= VictimAngle && VictimAngle < 147.5) //Back Right
			{
				Ret = 3;
			}
			Else If (abs(VictimAngle) >= 147.5) //Back
			{
				Ret = 4;
			}
			Else If (-147.5 < VictimAngle && VictimAngle <= -112.5) //Back Left
			{
				Ret = 5;
			}
			Else If (-112.5 < VictimAngle && VictimAngle <= -67.5) //Left
			{
				Ret = 6;
			}
			Else If (-67.5 < VictimAngle && VictimAngle <= -22.5) //Front Left
			{
				Ret = 7;
			}
			Return Ret;
		}
		Return -1;
	}
	Action Bool SavageryQueue()
	{
		PlayerInfo Player = Players[ConsolePlayer];
		Let Rune = Savagery(FindInventory("Savagery"));
		If (Tracer && Rune)
		{
			Let VictimInfo = New("SavageryArray");
			VictimInfo.Victim = Tracer;
			VictimInfo.ClassName = VictimInfo.Victim.GetClassName();
			VictimInfo.Angle = GetGKAngle();
			If (CountInv("PowerBerserk"))
			{
				VictimInfo.MOD = "Berserk";
			}
			Else If (CountInv("ChainsawRipAndTear"))
			{
				VictimInfo.MOD = "Chainsaw";
			}
			Else
			{
				VictimInfo.MOD = "Normal";
			}
			VictimInfo.DeathFromAbove = CountInv("DeathFromAbove");
			For (Int i = 0; i < Rune.SavageryMastery.Size(); i++)
			{
				If (Rune.SavageryMastery[i].ClassName == VictimInfo.ClassName && Rune.SavageryMastery[i].Angle == VictimInfo.Angle && Rune.SavageryMastery[i].MOD == VictimInfo.MOD && Rune.SavageryMastery[i].DeathFromAbove == VictimInfo.DeathFromAbove)
				{
					Return False;
				}
			}
			Rune.SavageryMastery.Push(VictimInfo);
			Return True;
		}
		Return False;
	}
	Action Bool CheckOnGround()
	{
		Return Player.OnGround;
	}
	Action Bool CheckTracerOnGround()
	{
		Return (Tracer && (Tracer.Pos.Z == Tracer.FloorZ && !Tracer.bNOGRAVITY)); //Work on flying monsters and non-flying monsters that are in the air for whatever reason.
	}
	Static Bool CheckOnGroundFunction(Actor Activator)
	{
		If (Activator && Activator.Player)
		{
			Return Activator.Player.OnGround;
		}
		Return False;
	}
	Action Bool CheckInfiniteAmmo()
	{
		Return (GetCVar("SV_InfiniteAmmo") || FindInventory("PowerInfiniteAmmo", True));
	}
	Static Bool CheckInfiniteAmmoFunction(Actor Activator)
	{
		If (Activator && Activator.Player)
		{
			Return (Activator.GetCVar("SV_InfiniteAmmo") || Activator.FindInventory("PowerInfiniteAmmo", True));
		}
		Return False;
	}
	Action Void EOA_SpawnCustomDynamicLight(Name LightID, Int Type = DynamicLight.PointLight, Vector3 RGB = (0, 0, 0), Int Radius1 = 0, Int Radius2 = 0, Int Flags = 0, Int Duration = 8, Vector3 Ofs = (0, 0, 0), Double Param = 0, Double SpotI = 10, Double SpotO = 25, Double SpotP = 0)
	{
		EOA_ActorExtensions.SpawnCustomDynamicLight(Self, LightID, Type, RGB, Radius1, Radius2, Flags, Duration, Ofs, Param, SpotI, SpotO, SpotP);
	}
	Action Void EOA_SpawnNoiseMaker(Sound WhatToPlay = "Weapons/Pistol", Int Flags = 0, Double Volume = 1.0, Double Attenuation = ATTN_NORM, Double Pitch = 0.0)
	{
		EOA_ActorExtensions.SpawnNoiseMaker(Invoker.Owner, WhatToPlay, Invoker.SlotNumber + 10, Flags|CHANF_OVERLAP, Volume, Attenuation, Pitch);
	}
	Action Void EOA_SpawnPersistentNoiseMaker(Double ID, Sound WhatToPlay = "Weapons/Pistol", Int Slot = CHAN_BODY, Int Flags = 0, Double Volume = 1.0, Double Attenuation = ATTN_NORM, Double Pitch = 0.0)
	{
		Slot += ID * 100;
		If (!WhatToPlay)
		{
			Invoker.Owner.A_StopSound(Slot);
		}
		Else
		{
			Invoker.Owner.A_StartSound(WhatToPlay, Slot, Flags|CHANF_LISTENERZ, Volume, Attenuation, Pitch);
			Invoker.Owner.A_SoundVolume(Slot, Volume);
		}
	}
	Action Void EOA_DestroyPersistentNoiseMaker(Double ID, Int Range = 10, Int Offset = 0)
	{
		For (Int i = 0; i < Range; i++)
		{
			Invoker.Owner.A_StopSound(ID * 100 + i + Offset);
		}
	}
	Action Void A_FireGrapple()
	{
		Invoker.Special1=0;
		If(Invoker.special2>0)
		Invoker.Special2=0;
		//A_PlaySound(slot:chan_weapon);
		Invoker.Tracer=A_FireProjectile("SSGGrapple");
		A_GunFlash();
		If(Invoker.Tracer)
		Invoker.Tracer.Master=Invoker;
		A_Overlay(6,"InputCheck");
	}
	Action Void A_FireFlameGrapple()
	{
		Invoker.Special1=0;
		If(Invoker.special2>0)
		Invoker.Special2=0;
		//A_PlaySound(slot:chan_weapon);
		Invoker.Tracer=A_FireProjectile("FlameSSGGrapple");
		A_GunFlash();
		If(Invoker.Tracer)
		Invoker.Tracer.Master=Invoker;
		A_Overlay(6,"InputCheck");
	}
	Action Bool CheckPButtons(Int BT)
	{
		If((Player.cmd.buttons & BT) && Player.Health>0)
		Return True;
		Return False;
	}
	
	Action Void EOA_CheckBloodPunch()
	{
		Double ClosestDist = Double.Infinity;
		//Double ClosestAng = CameraFOV / 2;
		Actor Victim;
		BlockThingsIterator It = BlockThingsIterator.Create(Invoker.Owner, 1024); //300 * (1 + CountInv("SeekAndDestroySelected")) * (1 + CountInv("SeekAndDestroySelected") && CountInv("SeekAndDestroyII")));
		While (It.Next())
		{
			Actor Mo = It.Thing;  
			//&& abs(Victim.Pos.Z - Pos.Z) <= Height &&
			If (Mo && AbsAngle(AngleTo(Mo), Angle) <= CameraFOV / 2 && !Mo.bKILLED && Mo.bISMONSTER && !Mo.bNODAMAGE && !Mo.bDORMANT && CheckSight(Mo) && abs(Mo.Pos.Z - Pos.Z) <= Height + 20 && CheckIfCloser(Mo, 240) && !CountInv("RipAndTear") && !Mo.CountInv("GloryKillCounter"))
			{                      
				//Double Ang = AbsAngle(AngleTo(Mo), Angle);
				//If (Ang < ClosestAng)
				Double Dist = Distance3D(Mo);
				If (Dist < ClosestDist)
				{
					//ClosestAng = Ang;
					ClosestDist = Dist;
					Victim = Mo;
				}
			}
			Else If (Mo && AbsAngle(AngleTo(Mo), Angle) <= CameraFOV / 2 && !Mo.bKILLED && Mo.bISMONSTER && !Mo.bNODAMAGE && !Mo.bDORMANT && CheckSight(Mo) && CheckIfCloser(Mo, 142) && !CountInv("RipAndTear") && !Mo.CountInv("GloryKillCounter"))
			{                      
				//Double Ang = AbsAngle(AngleTo(Mo), Angle);
				//If (Ang < ClosestAng)
				Double Dist = Distance3D(Mo);
				If (Dist < ClosestDist)
				{
					//ClosestAng = Ang;
					ClosestDist = Dist;
					Victim = Mo;
				}
			}
		}
		If (Victim)
		{
			Tracer = Victim; //Have the victim be stored in the player's Tracer pointer.
			A_GiveInventory("BloodAndGuts");
		}
	}
	
	Action Void EOA_CheckCrucibleKill()
	{
		Double ClosestDist = Double.Infinity;
		//Double ClosestAng = CameraFOV / 2;
		Actor Victim;
		BlockThingsIterator It = BlockThingsIterator.Create(Invoker.Owner, 1024); //300 * (1 + CountInv("SeekAndDestroySelected")) * (1 + CountInv("SeekAndDestroySelected") && CountInv("SeekAndDestroyII")));
		While (It.Next())
		{
			Actor Mo = It.Thing;  
			//If (Mo && AbsAngle(AngleTo(Mo), Angle) <= CameraFOV / 2 && !Mo.bKILLED && Mo.bISMONSTER && !Mo.bDORMANT && CheckSight(Mo) && (Distance3D(Mo) <= 192 * 1 * 1 + Mo.Radius) && !CountInv("RipAndTear") && !Mo.CountInv("GloryKillCounter") && (Mo.CountInv("PowerStaggered") || (CountInv("PowerCrucible"))))
			If (Mo && AbsAngle(AngleTo(Mo), Angle) <= CameraFOV / 2 && !Mo.bKILLED && Mo.bISMONSTER && !Mo.bNODAMAGE && !Mo.bDORMANT && CheckSight(Mo) && CheckIfCloser(Mo, 192 * 1 * 1 + Mo.Radius) && !CountInv("RipAndTear") && !Mo.CountInv("GloryKillCounter") && (Mo.CountInv("PowerStaggered") || (CountInv("PowerCrucible"))))
			{                      
				//Double Ang = AbsAngle(AngleTo(Mo), Angle);
				//If (Ang < ClosestAng)
				Double Dist = Distance3D(Mo);
				If (Dist < ClosestDist)
				{
					//ClosestAng = Ang;
					ClosestDist = Dist;
					Victim = Mo;
				}
			}
		}
		If (Victim)
		{
			Tracer = Victim; //Have the victim be stored in the player's Tracer pointer.
			A_GiveInventory("RipAndTear");
			Victim.A_GiveInventory("StaggerItem");
			Victim.A_GiveInventory("GloryKillCounter");
			Victim.bNOTARGETSWITCH = True;
			Victim.bNEVERTARGET = True;
			//Victim.bNODAMAGE = True;
		}
	}
	
	Action Void A_BloodPunch() //[DoomKrakken]: Derived from A_Blast.  Modified to only work within a certain angle. :D
	{
		Bool BloodCheck;
		Actor BloodWave;
		[BloodCheck, bloodWave] = A_SpawnItemEx("BloodpunchWave", 0, 0, Height / 2, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);//Spawn("HeatBlastWave", (Pos.X, Pos.Y, Pos.Z + Height / 2), NO_REPLACE);
		If (BloodWave)
		{
			//[DoomKrakken]: Spawn four more in the same fashion, for better brightness. :D
			//[Fat Tony]: maybe.....
			A_SpawnItemEx("BloodpunchWave", 0, 0, Height / 1.7, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);
			A_SpawnItemEx("BloodpunchWave", 0, 0, Height / 1.5, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);
			A_SpawnItemEx("BloodpunchWave", 0, 0, Height / 1.7, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);
			A_SpawnItemEx("BloodpunchWave", 0, 0, Height / 1.5, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);
			A_SpawnItemEx("BloodpunchWave", 0, 0, Height / 1.7, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);
			A_SpawnItemEx("BloodpunchWave", 0, 0, Height / 1.5, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);
			A_SpawnItemEx("BloodpunchWave", 0, 0, Height / 1.7, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);
			A_SpawnItemEx("BloodpunchWave", 0, 0, Height / 1.5, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);
		}
		ThinkerIterator it = ThinkerIterator.Create("Actor");
		Actor Mo;
		While (Mo = Actor(it.Next()))
		{
			//Check for the Heat Blast Wave
			If (!BloodWave)
			{
				Continue;
			}
			//Don't shoot yourself in the foot, m80. ;)
			If (Mo == Self)
			{
				Continue;
			}
			
			//Can't shoot what ya can't shoot... wait what?
			If (!Mo.bSHOOTABLE)
			{
				Continue;
			}
			
			//Out of range.
			If (Distance3D(Mo) > 350)
            {
                Continue;
            }			
			//Gotta be somewhat in front of you.  Remember, this heat blast isn't a fart... (thank you, Kodi, Xangi, and Gutawer!)
			Vector3 posDif = self.Vec3To(Mo); //Difference in position between inflictor and victim.
			Double relAngle = DeltaAngle(Self.Angle, atan2(posDif.Y, posDif.X)); //Difference in angle between inflictor and victim.
            If (abs(relAngle) >= 45.0)
            {
                Continue;
            }
			
			//No wall hax.
			If (mo.CurSector.PortalGroup != CurSector.PortalGroup || !CheckSight(Mo))
			{
				Continue;
			}
			
			//DED.
			If (Mo.bKILLED)
			{
				Continue;
			}
			Mo.Target = Self;
			FalterDemon(Mo);
			Int Damage = 200;
			/*if(CountInv("BloodierPunch"))
			{
				Mo.DamageMobj(BloodWave, Self, 370, "Normal");
			}
			if(!CountInv("BloodierPunch"))
			{*/
				A_GiveInventory("StyleCounter", 5 - CountInv("SwitchStyleDelay")/5);
				Mo.DamageMobj(BloodWave, Self, Damage * (1 + CountInv("BloodierPunch") + (Mo Is "Demon")), "Extreme");
			//}
			Mo.A_FaceTarget();
		}
	}

	Static Void FalterDemon(Actor Mo)
	{
		Mo.bFORCEPAIN = True;
		Mo.PainChance = 256;
		Mo.DamageMobj(Mo, Mo, 0, "Normal");
		Mo.PainChance = Mo.Default.PainChance;
		Mo.bFORCEPAIN = Mo.Default.bFORCEPAIN;
	}

	Action Void A_Crucible() //[DoomKrakken]: Derived from A_Blast.  Modified to only work within a certain angle. :D
	{
		Bool CrucibleCheck;
		Actor CrucibleWave;
		[CrucibleCheck, CrucibleWave] = A_SpawnItemEx("CrucibleBladeWave", 0, 0, Height / 2, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);//Spawn("HeatBlastWave", (Pos.X, Pos.Y, Pos.Z + Height / 2), NO_REPLACE);
		If (CrucibleWave)
		{
			//BlastWave.Pitch = Pitch;
			//BlastWave.Angle = Angle;
			//[DoomKrakken]: Spawn four more in the same fashion, for better brightness. :D
			A_SpawnItemEx("CrucibleBladeWave", 0, 0, Height / 2, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);
			A_SpawnItemEx("CrucibleBladeWave", 0, 0, Height / 1.9, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);
			A_SpawnItemEx("CrucibleBladeWave", 0, 0, Height / 1.8, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);
			A_SpawnItemEx("CrucibleBladeWave", 0, 0, Height / 1.7, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);
		}
	}
	Action Void SawThing()
	{
		PlayerInfo Player = Players[ConsolePlayer];
		A_FireProjectile("EOA_GKSeeker", 0, 0, 0, 0);
		A_CustomPunch(0, 1, 0, "EOA_NullPuff2", 192 * ((1 + CountInv("SeekAndDestroySelected")) * (1 + (CountInv("SeekAndDestroySelected") && CountInv("SeekAndDestroyII")))));
		//A_GunFlash("Null");
		Player.FindPSprite(PSP_WEAPON).SetState(ResolveState("QuickChainsawGloryKill"));
			
		//Return ResolveState("QuickChainsawGloryKill");
		
	}
	States
	{
	//[DoomKrakken]: For GetSpriteIndex, in order to properly load and set these sprites correctly.
	IdleState: 
		RDAI A 1;
		Loop;
	FireState:
		RDAF A 1;
		Loop;
	LoadState:
		RDAL A 1;
		Loop;
	RaiseState:
		RDAR A 1;
		Loop;
	TossState:
		RDAT A 1;
		Loop;
	EquipmentHandler:
		TNT1 A 1
		{
			If (CountInv("FlameTrigger") && CountInv("FlameBelch"))
			{
				A_Overlay(-51, "FlameBelch");
			}
			If (CountInv("IceTrigger") && CountInv("IceBomb") | CountInv("FragGrenade"))
			{
				A_Overlay(-51, "IceBomb");
			}
			If (CountInv("GrenadeTrigger") && CountInv("FragGrenade"))
			{
				A_Overlay(-51, "GrenadethrowStart");
			}
			If (CountInv("EOA_Chainsaw") && CountInv("SawTrigger") && GetCVar("EOAE_InfiniteBerserk") == false)
			{
				A_Overlay(-52, "Quicksaw", 1);
			}
		}
		Loop;
	InputCheck:
		TNT1 A 1
		{
			If(CountInv("SuperShotgunSelected"))
			{
				Invoker.Owner.A_GiveInventory("DoubleJumpCounter");
				If(!CheckPButtons(BT_ALTATTACK) || !Invoker.Tracer || Invoker.Tracer && Distance3D(Invoker.Tracer)<65 && Invoker.Tracer.Tracer)
				{
					//If(!Invoker.Tracer || Invoker.Special2<0)
					//A_Overlay(PSP_WEAPON,"Release",0);
					If(Invoker.Tracer)
					Invoker.Tracer.Destroy();
					//A_ChangeVelocity(0, 0, 10, CVF_RELATIVE);
					Invoker.Owner.A_TakeInventory("SSGUsingHook");
					Return ResolveState("Null");
				}
				Else If(Invoker.Owner.GetPlayerInput(INPUT_BUTTONS) & BT_JUMP || !Invoker.Tracer || Invoker.Tracer && Distance3D(Invoker.Tracer)<65 && Invoker.Tracer.Tracer)
				{
					//If(!Invoker.Tracer || Invoker.Special2<0)
					//A_Overlay(PSP_WEAPON,"Release",0);
					If(Invoker.Tracer)
					Invoker.Tracer.Destroy();
					A_ChangeVelocity(0, 0, 3, CVF_RELATIVE);
					Invoker.Owner.A_TakeInventory("SSGUsingHook");
					Return ResolveState("Null");
				}
				Vector2 olddir=(angle,pitch);
				A_Face(Invoker.Tracer,0,0);
				//A_CustomRailgun(0,5,"Gray","",RGF_SILENT,PuffType:"InvisiblePuff",Range:Distance3D(Invoker.Tracer),1);
				//A_CustomRailgun(0,5,"Gray","",RGF_SILENT,PuffType:"InvisiblePuff",Range:Distance3D(Invoker.Tracer),1 , 0.75);
				//A_CustomRailgun(0,5,"Gray","",RGF_SILENT,PuffType:"InvisiblePuff",Range:Distance3D(Invoker.Tracer),1 , 0.5);
				If(Invoker.Owner.CountInv("doubletrouble"))
				{
					A_CustomRailgun(0,5,"","Tan",RGF_SILENT,PuffType:"InvisiblePuff",Range:Distance3D(Invoker.Tracer),1 , 0.25);
				}
				Else
				{
					A_CustomRailgun(0,5,"","Gray",RGF_SILENT,PuffType:"InvisiblePuff",Range:Distance3D(Invoker.Tracer),1 , 0.25);
				}
				Vector2 Dir=(Angle,Pitch);
				Angle=olddir.X;
				Pitch=olddir.Y;
				If(Level.Time%5==0)
				SetStateLabel("Missile");
				If(Invoker.Tracer.Tracer)
				{
					Double MoveSpeed=25;
					Double SideMove=0;
					If(Invoker.Owner.GetPlayerInput(INPUT_BUTTONS) & BT_MOVELEFT)
					{
						SideMove+=95 / (Distance3D(Invoker.Tracer)/100);
					}
					else If(Invoker.Owner.GetPlayerInput(INPUT_BUTTONS) & BT_MOVERIGHT)
					{
						SideMove-=95 / (Distance3D(Invoker.Tracer)/100);
					}
					//Vector2 Dir=LMBDLib.FaceVector(Invoker.Tracer.Tracer.pos,Player.mo.pos);
					//Vector3 V=((Cos(Dir.X)*MoveSpeed)*Cos(Dir.Y),(Sin(Dir.X)*MoveSpeed)*cos(Dir.Y),Sin(-Dir.Y)*MoveSpeed);
					Vector3 V=((Cos(Dir.X + SideMove)*MoveSpeed)*Cos(Dir.Y),(Sin(Dir.X + SideMove)*MoveSpeed)*cos(Dir.Y),Sin(-Dir.Y)*MoveSpeed);
					Vector3 OldPos=Pos;
					SetXYZ(Pos+V);
					Bool Moved=False;
					If(CheckMove(Pos.XY,1))
					Vel=V;
					Else
					Vel+=V*0.5;
					SetXYZ(OldPos);
					
				}
			}
			Return ResolveState(NULL);
		}
		Loop;
	Spawn:
	Ready:
	ReadyLoop:
	ReRaise:
	Select:
	Fire:
		TNT1 A 0 A_TakeInventory("EOA_Weapon");
	Deselect:
		TNT1 A 1 A_Lower(36);
		Wait;
	LedgeClimb:
		TNT1 A 0
		{
			EOA_SpawnNoiseMaker("Player/Mantle");
			A_GiveInventory("EOA_MantleCooldown");
		}
		//MNTL ABCDE 1 A_WeaponOffset(0, 48 + 32 * sin(-Pitch));
		MNTL ABCD 1 A_WeaponOffset(0, 20 + (Invoker.LedgeZStep * 16 - Invoker.MantleTics * (10 + (10 * CountInv("QuickHands")))) - pitch, WOF_INTERPOLATE);
		//LedgeZStep
		//MNTL FFGGHHIIJKLMN 1
		MNTL FR 2
		{
			A_WeaponOffset(0, 20 + (Invoker.LedgeZStep * 16 - Invoker.MantleTics * (10 + (10 * CountInv("QuickHands")))) - pitch, WOF_INTERPOLATE);
			If (CountInv("QuickHands"))
			{
				If (CountInv("SpeedCounter"))
				{
					A_TakeInventory("SpeedCounter");
				}
				Else
				{
					A_SetTics(0);
					A_GiveInventory("SpeedCounter");
				}
			}
		}
		TNT1 A 0
		{
			A_TakeInventory("Grabbing_A_Ledge");
			A_WeaponOffset();
			Return ResolveState("Readyloop"); //A_Jump(256, "ReRaise");
		}
		Goto Readyloop;
	WallClimb:
		TNT1 A 0 A_TakeInventory("DoTheClimb");
		CLST ABCDEF 1;
		TNT1 A 0 EOA_SpawnNoiseMaker("ClimbableWall/Use");
	WallClimbLoop:
		TNT1 A 1
		{
			if(CountInv("StopClimb"))
			{
				Return ResolveState("FinishClimb");
			}
			A_TakeInventory("DoTheClimb");
			A_Overlay(90, "LeftCArm", 1);
			A_Overlay(91, "RightCArm", 1);
			Return ResolveState(Null);
		}
		loop;
	FinishClimb:
		TNT1 A 0
		{
			A_WeaponOffset();
			A_TakeInventory("StopClimb");
			A_Overlay(90, "Null");
			A_Overlay(91, "Null");
			EOA_SpawnNoiseMaker("ClimbableWall/Use");
		}
		CLEN ABCDE 1;
		TNT1 A 0 A_Jump(256, "Ready");
		Goto Ready;
	LeftCArm:
		CRML A 1
		{
			PlayerInfo Player = Players[ConsolePlayer];
			Vector2 CMoveVec = (Player.cmd.SideMove, Player.cmd.ForwardMove);
			If(CMoveVec.Y == 0 && CMoveVec.X > 1)
			{
				Return ResolveState("MLLeftCArm");
			}
			Else If(CMoveVec.Y == 0 && CMoveVec.X < -1)
			{
				Return ResolveState("MRLeftCArm");
			}
			Else If(CMoveVec.Y > 1 && CMoveVec.X > 1)
			{
				Return ResolveState("MUD2LeftCArm");
			}
			Else If(CMoveVec.Y > 1 && CMoveVec.X < -1)
			{
				Return ResolveState("MUD1LeftCArm");
			}
			Else If(CMoveVec.Y < 1 && CMoveVec.x > 1)
			{
				Return ResolveState("MDD2LeftCArm");
			}
			Else If(CMoveVec.Y < 1 && CMoveVec.X < -1)
			{
				Return ResolveState("MDD1LeftCArm");
			}
			Else If(CMoveVec.Y > 1)
			{
				Return ResolveState("MULeftCArm");
			}
			Else If(CMoveVec.Y < -1)
			{
				Return ResolveState("MDLeftCArm");
			}
			Return ResolveState(Null);
		}
		Loop;
	RightCArm:
		CRMR A 1
		{
			PlayerInfo Player = Players[ConsolePlayer];
			Vector2 CMoveVec = (Player.cmd.SideMove, Player.cmd.ForwardMove);
			If(CMoveVec.Y == 0 && CMoveVec.X < -1)
			{
				Return ResolveState("MLRightCArm");
			}
			Else If(CMoveVec.Y == 0 && CMoveVec.X > 1)
			{
				Return ResolveState("MRRightCArm");
			}
			Else If(CMoveVec.Y > 1 && CMoveVec.X > 1)
			{
				Return ResolveState("MDD1RightCArm");
			}
			Else If(CMoveVec.Y > 1 && CMoveVec.X < -1)
			{
				Return ResolveState("MDD2RightCArm");
			}
			Else If(CMoveVec.Y < 1 && CMoveVec.x > 1)
			{
				Return ResolveState("MUD2RightCArm");
			}
			Else If(CMoveVec.Y < 1 && CMoveVec.X < -1)
			{
				Return ResolveState("MUD1RightCArm");
			}
			Else If(CMoveVec.Y > 1)
			{
				Return ResolveState("MURightCArm");
			}
			Else If(CMoveVec.Y < -1)
			{
				Return ResolveState("MDRightCArm");
			}
			Return ResolveState(Null);
			
		}
		Loop;
	//iam 95.6432% sure there is a way better method to do this iam just lazy
	MUD1LeftCArm:
		D1ML AABCDEFGGHIJ 2;
		TNT1 A 0 EOA_SpawnNoiseMaker("ClimbableWall/Walk", 0, 0.5);
		Goto LeftCArm;
	MUD2LeftCArm:
		D2ML AABCDEFGGHIJ 2;
		TNT1 A 0 EOA_SpawnNoiseMaker("ClimbableWall/Walk", 0, 0.5);
		Goto LeftCArm;
	MDD2LeftCArm:
		D1ML JIHGGFEDCBAA 2;
		TNT1 A 0 EOA_SpawnNoiseMaker("ClimbableWall/Walk", 0, 0.5);
		Goto LeftCArm;
	MDD1LeftCArm:
		D2ML JIHGGFEDCBAA 2;
		TNT1 A 0 EOA_SpawnNoiseMaker("ClimbableWall/Walk", 0, 0.5);
		Goto LeftCArm;	
	MULeftCArm:
		CRML AABCDEFGGHIJ 2;
		TNT1 A 0 EOA_SpawnNoiseMaker("ClimbableWall/Walk", 0, 0.5);
		Goto LeftCArm;
	MDLeftCArm:
		CRML JIHGGFEDBAA 2;
		TNT1 A 0 EOA_SpawnNoiseMaker("ClimbableWall/Walk", 0, 0.5);
		Goto LeftCArm;
	MRLeftCArm:
		HRML AABCDEFGGHIJ 2;
		TNT1 A 0 EOA_SpawnNoiseMaker("ClimbableWall/Walk", 0, 0.5);
		Goto LeftCArm;
	MLLeftCArm:
		HRML JIHGGFEDBAA 2;
		TNT1 A 0 EOA_SpawnNoiseMaker("ClimbableWall/Walk", 0, 0.5);
		Goto LeftCArm;
	MUD1RightCArm:
		D1MR FFGHIJ 2;
		TNT1 A 0 EOA_SpawnNoiseMaker("ClimbableWall/Walk", 0, 0.5);
		D1MR AABCDE 2;
		Goto RightCArm;
	MUD2RightCArm:
		D2MR FFGHIJ 2;
		TNT1 A 0 EOA_SpawnNoiseMaker("ClimbableWall/Walk", 0, 0.5);
		D2MR AABCDE 2;
		Goto RightCArm;
	MDD2RightCArm:
		D2MR FFGHIJ 2;
		TNT1 A 0 EOA_SpawnNoiseMaker("ClimbableWall/Walk", 0, 0.5);
		D2MR AABCDE 2;
		Goto RightCArm;
	MDD1RightCArm:
		D1MR FFGHIJ 2;
		TNT1 A 0 EOA_SpawnNoiseMaker("ClimbableWall/Walk", 0, 0.5);
		D1MR AABCDE 2;
		Goto RightCArm;	
	MURightCArm:
		CRMR EFG 2;
		TNT1 A 0 EOA_SpawnNoiseMaker("ClimbableWall/Walk", 0, 0.5);
		CRMR GHIJAABCD 2;
		Goto RightCArm;
	MDRightCArm:
		CRMR EDB 2;
		TNT1 A 0 EOA_SpawnNoiseMaker("ClimbableWall/Walk", 0, 0.5);
		CRMR AAJIHGGF 2;
		Goto RightCArm;
	MRRightCArm:
		HRMR AABCDEFG 2;
		TNT1 A 0 EOA_SpawnNoiseMaker("ClimbableWall/Walk", 0, 0.5);
		HRMR GHIJ 2;
		Goto RightCArm;
	MLRightCArm:
		HRMR JIHG 2;
		TNT1 A 0 EOA_SpawnNoiseMaker("ClimbableWall/Walk", 0, 0.5);
		HRMR GFEDBAA 2;
		Goto RightCArm;
	MonkeyPole:
		TNT1 A 0 A_TakeInventory("ClimbHand");
		MNK2 A 1 
		{
			PlayerInfo Player = Players[ConsolePlayer];
			A_WeaponOffset(0, (Player.Mo.Pos.Z - Invoker.MonkeyZpos),WOF_KEEPX|WOF_ADD);
		}
		//MNKP DEFGH 2
		MNK2 ABBB 1 
		{
			PlayerInfo Player = Players[ConsolePlayer];
			A_WeaponOffset(0, (Player.Mo.Pos.Z - Invoker.MonkeyZpos),WOF_KEEPX|WOF_ADD);
			If (CountInv("QuickHands"))
			{
				If (CountInv("SpeedCounter"))
				{
					A_TakeInventory("SpeedCounter");
				}
				Else
				{
					A_SetTics(0);
					A_GiveInventory("SpeedCounter");
				}
			}
		}
		TNT1 A 0 {A_WeaponOffset(); A_TakeInventory("ClimbHand");}
		TNT1 A 0 A_Jump(256, "Ready");
		Goto Ready;
	HammerSmash:
		HAMS A 1
		{
			A_TakeInventory("DEHellBreakerSmash");
			A_GiveInventory("HammerSmashing");
			A_ChangeVelocity(0, 0, 16, CVF_RELATIVE);
			SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
			bDONTTHRUST = True;
		}
		HAMS BDFGHIJ 1
		{
			if(Player.OnGround)
			{
				bDONTTHRUST = False;
				A_StartSound("Gauss/Impact", 2);
				A_SpawnItemEx("HammerStunProjectile", 0, 0, -10);
				Return ResolveState("HammerSmashContinue");
			}
			Return ResolveState(Null);
		}
		HAMS J 7
		{
			if(Player.OnGround)
			{
				bDONTTHRUST = False;
				A_StartSound("Gauss/Impact", 2);
				A_SpawnItemEx("HammerStunProjectile", 0, 0, -10);
				Return ResolveState("HammerSmashContinue");
			}
			Return ResolveState(Null);
		}
		HAMS J 1
		{
			A_ChangeVelocity(0, 0, -12, CVF_RELATIVE);
			if(Player.OnGround)
			{
				bDONTTHRUST = False;
				A_StartSound("Gauss/Impact", 2);
				A_SpawnItemEx("HammerStunProjectile", 0, 0, -10);
				Return ResolveState("HammerSmashContinue");
			}
			Return ResolveState(Null);
		}
		Wait;
	HammerSmashContinue:
		TNT1 A 0 
		{
			A_TakeInventory("SwitchStyleDelay", 10);
			If(!CheckInfiniteAmmo())
			{
				A_TakeInventory("CrucibleAmmo", 2);
			}
		}
		HAMS KMOPOPO 1 A_QuakeEx( 2, 2, 2, 2, 0, 18,0,QF_RELATIVE);
		TNT1 A 0
		{
			A_TakeInventory("HammerSmashing");
			A_WeaponOffset();
			A_StopSound(10);
			A_StartSound("Eternal/Crucible/Deselect", 10);
			A_StartSound("Eternal/Crucible/Return", 10, CHANF_OVERLAP);
		}
		Goto Readyloop;
	Melee:
		"####" "#" 0
		{
			EOA_SetMeleeDelay();
			EOA_MeleeDash();
		}
		"####" A 0
		{
			If ((GetPlayerInput(INPUT_BUTTONS) & BT_ZOOM) && !(GetPlayerInput(INPUT_OLDBUTTONS) & BT_ZOOM))
			{
				EOA_CheckParry();
				EOA_CheckGloryKill();
				If(CountInv("BloodPunch"))
				{EOA_CheckBloodPunch();}
			}
			If (CountInv("RipAndTear"))
			{
				A_FireProjectile("EOA_GKSeeker", 0, 0, 0, 0);
				A_CustomPunch(0, 1, 0, "EOA_NullPuff2", 192 * ((1 + CountInv("SeekAndDestroySelected")) * (1 + (CountInv("SeekAndDestroySelected") * CountInv("SeekAndDestroyII")))));
				Return ResolveState("GloryKill");
			}
			If (CountInv("BloodAndGuts") && CountInv("bloodpunchcounter")==2 || CountInv("BloodAndGuts") && CountInv("extrabloodpunchcounter") == 2) //Strongbelly: Checking if monster has it to perform blood punch
			{
				A_CustomPunch(0, 1, 0, "EOA_NullPuff2", 112);
				Return ResolveState("BloodPunch");
			}
			Else
			{
				A_TakeInventory("BloodAndGuts"); //Strongbelly: Maintenance in case you have it when doing just the normal quick melee.
			}
			Return ResolveState(Null);
		}
		"####" A 2 A_WeaponOffset(50, 100, WOF_INTERPOLATE);
		"####" B 0 A_WeaponOffset();
		"####" "#" 0 A_GunFlash("MeleeAttack", GFF_NOEXTCHANGE);
		Goto Budge+2;
		
	BloodPunch:
		"####" "#" 1;
		"####" "#" 0 EOA_SetMeleeDelay;
		"####" "#" 1 A_GunFlash("BloodPunchThing", GFF_NOEXTCHANGE);
		goto Budge+12;
		
	UseEquipment:
		"####" A 3 A_jumpif(Countinv("grenadeselected") && CountInv("FragGrenade") && CountInv("IceBomb"), "takegrenade");
		"####" A 3 A_jumpif(!Countinv("grenadeSelected") && CountInv("FragGrenade") && CountInv("IceBomb"), "givegrenade");
		Goto budge+24;
		
	TakeGrenade:
		"####" "#" 0 A_takeinventory("grenadeselected",1);
		"####" "#" 4 A_WeaponReady;
		"####" "#" 0 A_StartSound("IceBombSelected",1,1.0);
		goto budge+24;
		
	GiveGrenade:
		"####" "#" 0 A_giveinventory("grenadeselected",1);
		"####" "#" 4 A_WeaponReady;
		"####" "#" 0 A_StartSound("FragSelected",1,1.0);
		goto budge+24;
		
	ThrowShield:
		"####" "#" 1 A_Overlay(10,"LaunchShield",1);
		Goto Budge+24;
	
	LaunchShield:
		TNT1 A 0
		{
			//EOA_FireBullets(0, 0, 0, 0, "EOA_NullPuff", FBF_NORANDOMPUFFZ, 0, "ShieldProjectile", -5 + GetViewZ(), 12 + GetRelVelY() / 4);
			EOA_SpawnNoiseMaker("Shield/Launch", 9);
			EOA_SpawnNoiseMaker("Shield/Launch", 10);
		}
		//TNT1 A 1 A_TakeInventory("ThrowShield");
		Stop;
	Budge:
		TNT1 AAAAAAAAAAAAAAAAAAAAAAAAA 1
		{
			If (CountInv("RipAndTear"))
			{
				A_FireProjectile("EOA_GKSeeker", 0, 0, 0, 0);
				A_CustomPunch(0, 1, 0, "EOA_NullPuff2", 192 * ((1 + CountInv("SeekAndDestroySelected")) * (1 + (CountInv("SeekAndDestroySelected") * CountInv("SeekAndDestroyII")))));
				A_GunFlash("Null");
				Return ResolveState("GloryKill");
			}
			If (!EOA_CheckMeleeDelay() && (GetFrame() == 9 || GetFrame() == 4) && (GetPlayerInput(INPUT_BUTTONS) & BT_ATTACK) && !CheckSemiAuto())
			{
				A_SetTics(0);
			}
			If (!CheckSemiAuto() || ((GetPlayerInput(INPUT_BUTTONS) & BT_ATTACK) && !(GetPlayerInput(INPUT_OLDBUTTONS) & BT_ATTACK)))
			{
				A_WeaponReady(WRF_NOBOB|WRF_NOSWITCH|WRF_NOFIRE * EOA_CheckMeleeDelay()|WRF_NOFIRE * (GetFrame() > 4)|WRF_NOFIRE * !CheckSemiAuto());
			}
			Return ResolveState(Null);
		}
		TNT1 A 0 A_Jump(256, "ReadyLoop");
		Goto ReadyLoop;
	
	FlameBelchStart:
		"####" "#" 1 A_Overlay(10,"FlameBelch",1);
		Goto Budge+24;
		
	FlameBelch:
		TNT1 A 0 A_GiveInventory("ShoulderInv", 1);
		TNT1 A 0 A_TakeInventory("FlameTrigger",1);
		SCF0 A 0 EOA_SpawnNoiseMaker("FlameBelch");
		CNNR A 0;
		"####" ACE 1;
		CNNF A 0;
		"####" A 3;
		"####" A 0 A_AlertMonsters();
		"####" A 0 A_GiveInventory("FlameThrowerCooldownToken",25);
		"####" A 0 ACS_NAMEDEXECUTEALWAYS("FlameCooldown");
		"####" B 2 bright A_GunFlash;
		"####" A 0 A_QuakeEx( 2, 2, 2, 2, 0, 18,0,QF_RELATIVE);
		"####" CDB 1 bright A_FireProjectile("FlameBelchProjectile", -3, 0, Random(-14, -18), 10, FPF_NOAUTOAIM);
		"####" G 0 bright A_GunFlash;
		"####" CDB 1 bright A_FireProjectile("FlameBelchProjectile", -3, 0, Random(-14, -18), 10, FPF_NOAUTOAIM);
		"####" G 0 bright A_GunFlash;
		"####" CDB 1 bright A_FireProjectile("FlameBelchProjectile", -3, 0, Random(-14, -18), 10, FPF_NOAUTOAIM);
		"####" A 1 bright A_GunFlash;
		"####" CDB 1 bright A_FireProjectile("FlameBelchProjectile", -3, 0, Random(-14, -18), 10, FPF_NOAUTOAIM);
		"####" A 1 bright A_GunFlash;
		CNNR A 0;
		"####" DB 1;
		TNT1 A 9;
		TNT1 A 1 A_TakeInventory("ShoulderInv", 10);
		Stop;
		
	//Ice Bomb
	IceBombStart:
		"####" "#" 1 A_Overlay(10,"IceBomb",1);
		Goto Budge+24;
		
	IceBomb:
		TNT1 A 0 A_GiveInventory("ShoulderInv", 1);
		TNT1 A 0 A_TakeInventory("IceTrigger",1);
		TNT1 A 0 EOA_SpawnNoiseMaker("CannonLaunch");
		CNNR A 0;
		"####" ACE 1;
		"####" A 0;
		"####" E 1 A_Quake(8, 8, 0, 32);
		"####" A 0
		{
			if(!countinv("FasterIceCooldown"))
			{
				A_GiveInventory("IceBombCooldownToken",40);
			}
			else if (countinv("FasterIceCooldown"))
			{
				A_GiveInventory("IceBombCooldownToken",20);	
			}
		}
		"####" A 0 ACS_NAMEDEXECUTEALWAYS("IceCooldown");
		"####" F 0 A_AlertMonsters();
		"####" F 0 bright A_GunFlash;
		CNNI A 0;
		"####" A 1 bright A_FireProjectile("IceBombProjectile", -3, 0, -18, 15, FPF_NOAUTOAIM, 0);
		"####" A 3 bright;
		CNNR A 0;
		"####" DCBA 1;
		TNT1 A 9;
		TNT1 A 1 A_TakeInventory("ShoulderInv", 10);
		Stop;
		
	//FragGrenade
	GrenadeThrowStart:
		"####" "#" 0 A_jumpif(!countinv("grenadeselected") && !Countinv("icebombcooldowntoken"), "IcebombStart");
		"####" "#" 0 A_Jumpif(CountInv("StockUp") && CountInv("ExtraNade"), "ExtraNadeThrow");
		"####" "#" 1 A_Overlay(10,"GrenadeThrow",1);
		Stop;
		
	ExtraNadeThrow:
		"####" "#" 1 A_Overlay(10,"ExtraGrenadeThrow",1);
		Stop;
	ExtraGrenadeThrow:
		TNT1 A 0 A_GiveInventory("ShoulderInv", 1);
		TNT1 A 0 
		{
			A_TakeInventory("GrenadeTrigger",1);
			A_TakeInventory("GrenadesAmount", 1);
			A_TakeInventory("ExtraNade");
		}
		TNT1 A 0 EOA_SpawnNoiseMaker("CannonLaunch");
		CNNR A 0;
		"####" ACD 1;
		"####" E 1;
		"####" F 0 bright A_GunFlash;
		CNNI A 0;
		"####" A 1 bright A_FireProjectile("EOAE_FragGrenadeProjectile", -3, 0, -18, 15, FPF_NOAUTOAIM, 0);
		"####" F 0 A_Quake(8, 8, 0, 32);
		"####" A 0 
		{
			if(!countinv("FasterFragCoolDown"))
			{
				A_GiveInventory("ExtraGrenadeCooldownToken",40);
			}
			else if (countinv("FasterFragCoolDown"))
			{
				A_GiveInventory("ExtraGrenadeCooldownToken",20);
			}
		}
		CNNR A 0;
		"####" E 0 ACS_NAMEDEXECUTEALWAYS("ExtranadeCooldown");
		"####" E 0 A_AlertMonsters();
		TNT1 A 1 A_TakeInventory("ShoulderInv", 10);
		Stop;
		
	GrenadeThrow:
		TNT1 A 0 A_GiveInventory("ShoulderInv", 1);
		TNT1 A 0 
		{
			A_TakeInventory("GrenadeTrigger",1);
			A_TakeInventory("GrenadesAmount",1);
		}
		TNT1 A 0 EOA_SpawnNoiseMaker("CannonLaunch");
		CNNR A 0;
		"####" ACD 1;
		"####" E 1;
		"####" F 0 bright A_GunFlash;
		CNNI A 0;
		"####" A 1 bright A_FireProjectile("EOAE_FragGrenadeProjectile", -3, 0, -18, 15, FPF_NOAUTOAIM, 0);
		"####" A 1 bright;
		"####" A 1 A_Quake(8, 8, 0, 32);
		"####" A 0 
		{
			If(!CountInv("ExtraGrenadeCooldownToken"))
			{
				if(!countinv("FasterFragCoolDown"))
				{
					A_GiveInventory("GrenadeCooldownToken",40);
				}
				else if (countinv("FasterFragCoolDown"))
				{
					A_GiveInventory("GrenadeCooldownToken",20);
				}
			}
			Else If (CountInv("ExtraGrenadeCooldownToken"))
			{
				A_GiveInventory("GrenadeCooldownToken", CountInv("ExtraGrenadeCooldownToken"));
				If(!CountInv("FasterFragCoolDown"))
				{
					A_GiveInventory("ExtraGrenadeCooldownToken", 40);
				}
				Else if(CountInv("FasterFragCoolDown"))
				{
					A_GiveInventory("ExtraGrenadeCooldownToken", 20);
				}
			}
		}
		"####" A 0 ACS_NAMEDEXECUTEALWAYS("GrenadeCooldown");
		"####" F 0 A_AlertMonsters();
		CNNR A 0;
		"####" EDCBA 1;
		TNT1 A 3;
		TNT1 A 1 A_TakeInventory("ShoulderInv", 10);
		Stop;
	//Quicksaw Attack
	Quicksaw:
		TNT1 A 0
		{
			A_AlertMonsters();
			A_GiveInventory("SawInv", 1);
			EOA_WeaponReady(WRF_NOFIRE);
			A_CustomPunch(0, 0, CPF_NOTURN, "ChainsawGloryKillChecker", 192 * ((1 + CountInv("SeekAndDestroySelected")) * (1 + (CountInv("SeekAndDestroySelected") && CountInv("SeekAndDestroyII")))));
			A_CustomPunch(0, 1, CPF_NOTURN, "ChainsawPuff");
		}
		/*TNT1 A 0
		{
			If (!CountInv("EOA_FuelAmmo") && GetCVar("EOAE_InfiniteBerserk") == false)
			{
				EOA_SpawnNoiseMaker("QuickSawEmpty"); ACS_NamedExecute("NoFuel", 0);
				A_takeInventory("SawInv", 1);
				A_TakeInventory("SawTrigger", 10);
				Return ResolveState("NULL");
			}
			Else If (CountInv("NeededFuel") >= 3 && CountInv("EOA_FuelAmmo") < 3)
			{
				A_SetInventory("NeededFuel", 0);
				A_takeInventory("SawInv", 1);
				A_TakeInventory("SawTrigger", 10);
				EOA_SpawnNoiseMaker("QuickSawEmpty"); ACS_NamedExecute("INVALIDTARGET", 0);
				Return ResolveState("NULL");
			}
			Return ResolveState(NULL);
		}*/
		TNT1 A 0 
		{
			EOA_SpawnNoiseMaker("QuickSaw");
			If (CountInv("ChainsawRipAndTear")){SawThing();}
			Else {ACS_NamedExecute("NOTARGET", 0);}
			A_takeInventory("SawInv", 1);
			A_TakeInventory("SawTrigger", 10);
		}
		Stop;
		
	QuickChainsawGloryKill:
		TNT1 A 0
		{
			A_Overlay(29, "NULL");
			A_Overlay(28, "NULL");
			EOA_SpawnPersistentNoiseMaker(Invoker.SlotNumber + 0.5, "", 5);
			EOA_SpawnPersistentNoiseMaker(Invoker.SlotNumber + 0.5, "", 6);
			SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
			bNOTARGET = bNOPAIN = bNODAMAGE = True;
			bNOGRAVITY = Tracer && Tracer.bNOGRAVITY;
			If (CountInv("SeekAndDestroySelected"))
			{
				EOA_SpawnNoiseMaker("Rune/SeekAndDestroy");
			}
		}
	QuickChainsawGloryTravel:
		TNT1 A 1;
		TNT1 A 0 A_Warp(AAPTR_MASTER, 0, 0, 0, 0, WARPF_TESTONLY, "QuickChainsawGloryTravel"); //[DoomKrakken]: The projectile itself has us do the warp.  This is here, doing the same thing, except it merely tests the very same conditions for the warp.  This way, it'll remain idle here until the warp fails.
		TNT1 A 1
		{
			A_WeaponOffset();
			A_SetPitch(0, SPF_INTERPOLATE);
			A_TransferPointer(AAPTR_DEFAULT, AAPTR_TRACER, AAPTR_DEFAULT, AAPTR_TARGET);
			A_Stop();
		}
		TNT1 A 0
		{
			Let Challenges = EOA_ChallengeArchive.Get();
			If (Challenges)
			{
				Challenges.QueueGK = True;
			}
			If (CountInv("SavagerySelected"))
			{
				EOA_SpawnNoiseMaker("Rune/Savagery");
				If (!CountInv("SavageryII") && SavageryQueue())
				{
					A_GiveInventory("SavageryChallengeCounter");
				}
			}
			If (CountInv("SeekAndDestroySelected") && !CountInv("SeekAndDestroyII"))
			{
				A_GiveInventory("SeekAndDestroyChallengeCounter");
			}
			If (CountInv("BloodFueledSelected") && !CountInv("BloodFueledII") && CountInv("PowerBloodFueledSpeed"))
			{
				A_GiveInventory("BloodFueledChallengeCounter");
			}
			If (CountInv("SavingThrowSelected") && !CountInv("SavingThrowII") && CountInv("PowerSavingThrow"))
			{
				A_GiveInventory("SavingThrowChallengeCounter");
			}
			If (CountInv("InFlightMobilitySelected") && !CountInv("InFlightMobilityII") && !CheckOnGround())
			{
				A_GiveInventory("InFlightMobilityChallengeCounter");
			}
		}
		QSW5 A 0 A_Jump(90, 3);
		QSW4 A 0 A_Jump(90, 2);
		QSW3 A 0;
		"####" ABCDEF 1;
		"####" F 0
		{
			A_Startsound("Chainsaw/Shoulder1", 7, CHANF_OVERLAP, 0.75);
			A_GiveInventory("GloryPunched", 1, AAPTR_TRACER);
		}
		/*"####" GFMGFMGFMGFMGFMGFMGFMGFMGFMGFM 1
		{
			A_WeaponOffset(frandom(-2, 2), frandom(32, 36));
			A_CustomPunch(0, 1, CPF_NOTURN, "EOA_MeleePuff", 192);
		}
		"####" GFGFG 1
		{
			A_SetTics(1 - CountInv("SavagerySelected"));
			A_WeaponOffset(frandom(-2, 2), frandom(32, 36));
			A_CustomPunch(0, 1, CPF_NOTURN, "EOA_MeleePuff", 192);
		}
		"####" GFMGFMGFMGFMGFM 1
		{
			A_SetTics(1 - (CountInv("SavagerySelected") && CountInv("SavageryII")));
			A_WeaponOffset(frandom(-2, 2), frandom(32, 36));
			A_CustomPunch(0, 1, CPF_NOTURN, "EOA_MeleePuff", 192);
		}*/
		"####" G 1
		{
			A_WeaponOffset(frandom(-2, 2), frandom(32, 36));
			A_CustomPunch(0, 1, CPF_NOTURN, "EOA_MeleePuff", 192);
		}
		/*"####" GFGFG 1
		{
			A_SetTics(1 - CountInv("SavagerySelected"));
			A_WeaponOffset(frandom(-2, 2), frandom(32, 36));
			A_CustomPunch(0, 1, CPF_NOTURN, "EOA_MeleePuff", 192);
		}
		"####" GFMGFMGFMGFMGFM 1
		{
			A_SetTics(1 - (CountInv("SavagerySelected") && CountInv("SavageryII")));
			A_WeaponOffset(frandom(-2, 2), frandom(32, 36));
			A_CustomPunch(0, 1, CPF_NOTURN, "EOA_MeleePuff", 192);
		}*/
		"####" "#" 0 
		{
			A_WeaponOffset();
			A_GiveInventory("GloryKilled", 1, AAPTR_TRACER);
		}
		"####" GHI 2;
		"####" "#" 0
		{
			SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
			bNOTARGET = bNOPAIN = bNODAMAGE = bNOGRAVITY = False;
			A_TakeInventory("ChainsawRipAndTear");
			A_TakeInventory("DeathFromAbove");
			If (!GetCVar("SV_InfiniteAmmo")) //MAD HACX for those who are into that sort of thing... ;)
			{
				A_TakeInventory("EOA_FuelAmmo", CountInv("ChainsawFuelCounter"));
			}
			A_TakeInventory("ChainsawFuelCounter");
			A_GiveInventory("BloodCounter");
			If (CountInv("ArmoredOffensiveSelected"))
			{
				EOA_SpawnNoiseMaker("Rune/ArmoredOffensive");
			}
			If (CountInv("BloodFueledSelected"))
			{
				EOA_SpawnNoiseMaker("Rune/BloodFueled");
				A_GiveInventory("PowerBloodfueledEFX");
				If (CountInv("BloodFueledII"))
				{
					A_GiveInventory("ExtendedBloodFueledSpeed");
				}
				Else
				{
					A_GiveInventory("BloodFueledSpeed");
				}
			}
		}
		TNT1 A 1
		{
			If (CountInv("EOA_FuelAmmo")<1)
			{
				A_GiveInventory("ChainsawCooldownToken",20);
				ACS_NamedExecuteAlways("ChainsawCooldown");
			}
		}	
		TNT1 A 0 A_takeInventory("SawInv", 1);
		TNT1 A 0 A_TakeInventory("SawTrigger", 10);
		TNT1 A 5;
		TNT1 A 0 A_jump(256, "ReadyLoop");
		Goto ReadyLoop;
	FragGrenadeToss:
		GHND ABCDEF 1;
		"####" "#" 0
		{
			EOA_SpawnNoiseMaker("Frag/Pin");
			A_FireProjectile("EOA_FragGrenadeProjectile", 0, 0, -10, 0, FPF_NOAUTOAIM, -5);
			A_TakeInventory("EquipmentCharge", 1);
			If (CountInv("EquipmentPowerSelected") && !CountInv("EquipmentPowerII"))
			{
				A_GiveInventory("EquipmentPowerChallengeCounter");
				A_GiveInventory("MasteryTicker");
			}
		}
		GHND GHIJKL 1;
		Stop;
	SiphonGrenadeToss:
		GHND ABCDEF 1;
		"####" "#" 0 
		{
			EOA_SpawnNoiseMaker("Frag/Pin");
			A_FireProjectile("EOA_SiphonGrenadeProjectile", 0, 0, -10, 0, CMF_TRACKOWNER, -5);
			A_TakeInventory("EquipmentCharge", 1);
			If (CountInv("EquipmentPowerSelected") && !CountInv("EquipmentPowerII"))
			{
				A_GiveInventory("EquipmentPowerChallengeCounter");
				A_GiveInventory("MasteryTicker");
			}
		}
		GHND GHIJKL 1;
		Stop;
	MeleeAttack:
		TNT1 A 0 EOA_SpawnNoiseMaker("Punch/Swing");
		MFST AC 1	
		{
			EOA_SetGKRecoilOffset(-5, 3, 3, True);
			If (GetPlayerInput(INPUT_BUTTONS) & BT_ZOOM)
			{
				EOA_CheckGloryKill();
			}
		}
		TNT1 A 0 
		{
			If (GetPlayerInput(INPUT_BUTTONS) & BT_ZOOM)
			{
				EOA_CheckGloryKill();
			}
			If (!CountInv("RipAndTear"))
			{
				A_CustomPunch(20, 1, CPF_NOTURN, "EOA_MeleePuff");
			}
		}
		MFST DEFHIKL 1
		{
			EOA_SetGKRecoilOffset(2, -1);
			If (GetPlayerInput(INPUT_BUTTONS) & BT_ZOOM && !(GetPlayerInput(INPUT_OLDBUTTONS) & BT_ZOOM))
			{
				EOA_CheckGloryKill();
				//A_CustomPunch(0, 1, CPF_NOTURN, "GloryKillChecker", 192 * (2 * CountInv("SeekAndDestroySelected") + 2 * (CountInv("SeekAndDestroySelected") * CountInv("SeekAndDestroyII"))));
			}
		}
		TNT1 AAAAAAAAAAAAAA 1 //18 tics, the remainder of the 25 in the "Budge" animation.
		{
			If ((GetPlayerInput(INPUT_BUTTONS) & BT_ZOOM) && !(GetPlayerInput(INPUT_OLDBUTTONS) & BT_ZOOM))
			{
				EOA_CheckGloryKill();
			}
		}
		Stop;
	Bloodpunchthing:
	    BLPN AC 1	EOA_SetGKRecoilOffset(-5, 3, 3, True);
		TNT1 A 0 
        {
				A_QuakeEx(2, 2, 2, 25, 0, 18,0,QF_RELATIVE);
				A_CustomPunch(100, 1, CPF_NOTURN, "EOA_MeleePuff");
				A_Bloodpunch();
				EOA_SpawnNoiseMaker("fist/blod");
                EOA_SetWeaponRecoilOffset(frandompick(-1, -0.5, 0.5, 1), -5, 0, 0.25);
				EOA_SpawnCustomDynamicLight("BPLight", DynamicLight.PointLight, (255, 0, 0), 94, 1, DYNAMICLIGHT.LF_ADDITIVE|DYNAMICLIGHT.LF_ATTENUATE, 4, (0, 0, Height / 2));
		}
		BLPN DFG 1 EOA_SetGKRecoilOffset(2, -1);
		TNT1 A 0 
			{
				if(!countinv("extrabloodpunchcounter"))
				{
					A_Takeinventory("bloodpunchcounter", 2);
				}
				Else if(countinv("extrabloodpunchcounter") == 1)
				{
					A_Takeinventory("extrabloodpunchcounter", 1);
					A_Takeinventory("bloodpunchcounter", 1);
				}
				Else if(countinv("extrabloodpunchcounter") == 2)
				{
					A_Takeinventory("extrabloodpunchcounter", 2);
				}
			}
		TNT1 A 0 A_TakeInventory("BloodAndGuts");
		Stop;
	GloryKill:
		TNT1 A 0
		{
			SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
			bNOTARGET = bNOPAIN = bNODAMAGE = True;
			bNOGRAVITY = Tracer && Tracer.bNOGRAVITY;
			If (CountInv("SeekAndDestroySelected"))
			{
				EOA_SpawnNoiseMaker("Rune/SeekAndDestroy");
			}
		}
	GloryTravel:
		TNT1 A 1;
		TNT1 A 0 A_Warp(AAPTR_MASTER, 0, 0, 0, 0, WARPF_TESTONLY, "GloryTravel"); //[DoomKrakken]: The projectile itself has us do the warp.  This is here, doing the same thing, except it merely tests the very same conditions for the warp.  This way, it'll remain idle here until the warp fails.
		TNT1 A 1 A_JumpIfInventory("DeathFromAbove", 1, "DeathFromAbove");
		TNT1 A 0
		{
			A_SetPitch(0, SPF_INTERPOLATE);
			//A_TakeInventory("PowerStaggered", 0, 0, AAPTR_TRACER);
			A_TransferPointer(AAPTR_DEFAULT, AAPTR_TRACER, AAPTR_DEFAULT, AAPTR_TARGET);
			A_Stop();
		}
		TNT1 A 0
		{
			Let Challenges = EOA_ChallengeArchive.Get();
			If (Challenges)
			{
				Challenges.QueueGK = True;
			}
			A_GiveInventory("StyleCounter", 5 - CountInv("SwitchStyleDelay")/5);
			If (CountInv("SavagerySelected"))
			{
				EOA_SpawnNoiseMaker("Rune/Savagery");
				If (!CountInv("SavageryII") && SavageryQueue())
				{
					A_GiveInventory("SavageryChallengeCounter");
					A_GiveInventory("MasteryTicker");
				}
			}
			If (CountInv("SeekAndDestroySelected") && !CountInv("SeekAndDestroyII"))
			{
				A_GiveInventory("SeekAndDestroyChallengeCounter");
				A_GiveInventory("MasteryTicker");
			}
			If (CountInv("BloodFueledSelected") && !CountInv("BloodFueledII") && CountInv("PowerBloodFueledSpeed"))
			{
				A_GiveInventory("BloodFueledChallengeCounter");
				A_GiveInventory("MasteryTicker");
			}
			If (CountInv("SavingThrowSelected") && !CountInv("SavingThrowII") && CountInv("PowerSavingThrow"))
			{
				A_GiveInventory("SavingThrowChallengeCounter");
				A_GiveInventory("MasteryTicker");
			}
			If (CountInv("InFlightMobilitySelected") && !CountInv("InFlightMobilityII") && !CheckTracerOnGround())
			{
				A_GiveInventory("InFlightMobilityChallengeCounter");
				A_GiveInventory("MasteryTicker");
			}
		}
		TNT1 A 0
		{
			if(CountInv("HitAndRun"))
			{
				A_GiveInventory("B5_DDash", 2);
			}
			If(CountInv("BloodPunch"))
			{
				if(countinv("extrabloodpunchcounter") == 1)
				{
					EOA_spawnnoisemaker("BloodPunchCharged", 0);
					ACS_NamedExecute("DrawReadyAnimR", 0, -140 - (100 * !CountInv("DoubleDash")), 45, 9);
				}
				if(countinv("ArmoredOffensiveSelected") && countinv("Bloodpunchcounter") == 2)
				{
					A_giveinventory("Extrabloodpunchcounter");
				}
				if(countinv("bloodpunchcounter") == 1)
				{
					EOA_spawnnoisemaker("BloodPunchCharged", 0);
					ACS_NamedExecute("DrawReadyAnimR", 0, -140 - (100 * !CountInv("DoubleDash")), 45, 9);
				}
				EOA_spawnnoisemaker("GloryKillDing", 0);
				if(CountInv("ArmoredOffensiveSelected"))
				{
					A_CustomPunch(0, 0, CPF_NOTURN, "EnemyHealthChecker", 192);
				}
				if(!CountInv("ArmoredOffensiveSelected"))
				{
					A_giveinventory("bloodpunchcounter", 1);
				}	
				if(Countinv("ArmoredOffensiveSelected") && CountInv("bloodpunchcounter") > 1)
				{
					EOA_spawnnoisemaker("BloodPunchCharged", 0);
				}
			}
		}
		TNT1 A 0 A_CheckFlag("BOSS", "CrucBossGloryKill", AAPTR_TRACER);
		TNT1 A 0 A_Jump(80, "CrucGloryKill2");
		TNT1 A 0 A_Jump(60, "GloryKill1");
		TNT1 A 0 A_Jump(75, "GloryKill2");
		TNT1 A 0 A_Jump(75, "GloryKill3");
		TNT1 A 0 A_Jump(75, "GloryKill4");
		//[DoomKrakken]: The following directions are in relation to the monster.
		/*TNT1 A 0 A_JumpIf(GetGKAngle() == 0, "GloryKill1"); //Front
		TNT1 A 0 A_JumpIf(GetGKAngle() == 1, "GloryKill2"); //Front Right
		TNT1 A 0 A_JumpIf(GetGKAngle() == 2, "GloryKill3"); //Right
		TNT1 A 0 A_JumpIf(GetGKAngle() == 3, "GloryKill4"); //Rear Right
		TNT1 A 0 A_JumpIf(GetGKAngle() == 4, "GloryKill5"); //Rear
		TNT1 A 0 A_JumpIf(GetGKAngle() == 5, "GloryKill6"); //Rear Left
		TNT1 A 0 A_JumpIf(GetGKAngle() == 6, "GloryKill7"); //Left
		TNT1 A 0 A_JumpIf(GetGKAngle() == 7, "GloryKill8"); //Front Left*/
	CrucGloryKill:
		TNT1 A 0 A_Jump(156, 2);
		TNT1 A 0 A_OverlayFlags(1, PSPF_FLIP|PSPF_MIRROR, 1);
		TNT1 A 0
		{
			A_StartSound("Eternal/Crucible/Swing", CHAN_WEAPON, CHANF_OVERLAP);
		}
		CGK1 ABCD 1 EOA_SetGKRecoilOffset(3.5, 1.5, -0.5);
		TNT1 A 0 
		{
			A_StartSound("Eternal/Crucible/Slice", CHAN_WEAPON, CHANF_OVERLAP);
			A_StartSound("CruciblePuffHit", CHAN_WEAPON, CHANF_OVERLAP);
			A_SpawnItemEx("CrucibleBladeWave", 0, 0, Height / 2, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKickPuff");
			A_GiveInventory("GloryKilled", 1, AAPTR_TRACER);
		}
		CGK1 EFGHIJ 1;
		TNT1 A 0 A_StartSound("Eternal/Crucible/Pickup", CHAN_WEAPON, CHANF_OVERLAP);
		Goto GloryKillEnd;
	CrucBossGloryKill:
		TNT1 A 0
		{
			A_StartSound("Eternal/Crucible/Swing", CHAN_WEAPON, CHANF_OVERLAP);
		}
		CGK1 ABCD 1 EOA_SetGKRecoilOffset(3.5, 1.5, -0.5);
		TNT1 A 0 
		{
			A_StartSound("Eternal/Crucible/Slice", CHAN_WEAPON, CHANF_OVERLAP);
			A_StartSound("CruciblePuffHit", CHAN_WEAPON, CHANF_OVERLAP);
			A_SpawnItemEx("CrucibleBladeWave", 0, 0, Height / 2, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKickPuff");
		}
		CGK1 EFGHIJ 1;
		TNT1 A 0 A_StartSound("Eternal/Crucible/Pickup", CHAN_WEAPON, CHANF_OVERLAP);
		TNT1 A 8;
		TNT1 A 0 A_OverlayFlags(1, PSPF_FLIP|PSPF_MIRROR, 1);
		TNT1 A 0
		{
			A_StartSound("Eternal/Crucible/Swing", CHAN_WEAPON, CHANF_OVERLAP);
		}
		CGK1 ABCD 1 EOA_SetGKRecoilOffset(3.5, 1.5, -0.5);
		TNT1 A 0 
		{
			A_StartSound("Eternal/Crucible/Slice", CHAN_WEAPON, CHANF_OVERLAP);
			A_StartSound("CruciblePuffHit", CHAN_WEAPON, CHANF_OVERLAP);
			A_SpawnItemEx("CrucibleBladeWave", 0, 0, Height / 2, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKickPuff");
		}
		CGK1 EFGHIJ 1;
		TNT1 A 0 A_StartSound("Eternal/Crucible/Pickup", CHAN_WEAPON, CHANF_OVERLAP);
		TNT1 A 6;
		TNT1 A 0 A_OverlayFlags(1, PSPF_FLIP|PSPF_MIRROR, 0);
		TNT1 A 0
		{
			A_StartSound("Eternal/Crucible/Swing", CHAN_WEAPON, CHANF_OVERLAP);
		}
		CGK1 ABCD 1 EOA_SetGKRecoilOffset(3.5, 1.5, -0.5);
		TNT1 A 0 
		{
			A_StartSound("Eternal/Crucible/Slice", CHAN_WEAPON, CHANF_OVERLAP);
			A_StartSound("CruciblePuffHit", CHAN_WEAPON, CHANF_OVERLAP);
			A_SpawnItemEx("CrucibleBladeWave", 0, 0, Height / 2, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKickPuff");
			A_GiveInventory("GloryKilled", 1, AAPTR_TRACER);
		}
		CGK1 EFGHIJ 1;
		TNT1 A 0 A_StartSound("Eternal/Crucible/Pickup", CHAN_WEAPON, CHANF_OVERLAP);
		Goto GloryKillEnd;
	CrucGloryKill2:
		TNT1 A 0 A_Jump(156, "CrucGloryKill2L");
		TNT1 A 0
		{
			A_StartSound("Eternal/Crucible/Swing", CHAN_WEAPON, CHANF_OVERLAP);
		}
		CGK2 ABCDE 1 EOA_SetGKRecoilOffset(3.5, 1.5, -0.5);
		TNT1 A 0 
		{
			
			A_StartSound("Eternal/Crucible/Slice", CHAN_WEAPON, CHANF_OVERLAP);
			A_StartSound("CruciblePuffHit", CHAN_WEAPON, CHANF_OVERLAP);
			A_SpawnItemEx("AngledRCrucibleBladeWave", 0, 0, Height / 2, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKickPuff");
			A_GiveInventory("GloryKilled", 1, AAPTR_TRACER);
		}
		CGK2 FGHI 1;
		TNT1 A 0 A_StartSound("Eternal/Crucible/Pickup", CHAN_WEAPON, CHANF_OVERLAP);
		Goto GloryKillEnd;
	CrucGloryKill2L:
		TNT1 A 0 A_OverlayFlags(1, PSPF_FLIP|PSPF_MIRROR, 1);
		TNT1 A 0
		{
			A_StartSound("Eternal/Crucible/Swing", CHAN_WEAPON, CHANF_OVERLAP);
		}
		CGK2 ABCDE 1 EOA_SetGKRecoilOffset(3.5, 1.5, -0.5);
		TNT1 A 0 
		{
			
			A_StartSound("Eternal/Crucible/Slice", CHAN_WEAPON, CHANF_OVERLAP);
			A_StartSound("CruciblePuffHit", CHAN_WEAPON, CHANF_OVERLAP);
			A_SpawnItemEx("AngledLCrucibleBladeWave", 0, 0, Height / 2, 0, 0, 0, 0, SXF_CLIENTSIDE|SXF_TRANSFERPITCH);
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKickPuff");
			A_GiveInventory("GloryKilled", 1, AAPTR_TRACER);
		}
		CGK2 FGHI 1;
		TNT1 A 0 A_StartSound("Eternal/Crucible/Pickup", CHAN_WEAPON, CHANF_OVERLAP);
		Goto GloryKillEnd;
	GloryKill1:
		MFST AB 1 EOA_SetGKRecoilOffset(-10.5, 7.5, 7.5);
		TNT1 A 0 
		{
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKillPuff");
			A_StartSound("Punch/GloryKill", CHAN_WEAPON, CHANF_OVERLAP);
			A_GiveInventory("GloryKilled", 1, AAPTR_TRACER);
		}
		MFST CDEFH 1
		{
			EOA_SetGKRecoilOffset(-1.5, -1.5);
			EOA_SetGKRecoilOffset(-1.5, -1.5);
		}
		TNT1 A 2
		{
			EOA_SetGKRecoilOffset(-3);
			EOA_SetGKRecoilOffset(-3);
			A_SetTics(2 * (1 - (0.5 * CountInv("SavagerySelected") + 0.5 * (CountInv("SavagerySelected") && (CountInv("SavageryII"))))));
		}
		Goto GloryKillEnd;
	GloryKill2: 
		MFS2 AB 1 EOA_SetGKRecoilOffset(10.5, 7.5, -7.5);
		TNT1 A 0 
		{
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKillPuff");
			A_StartSound("Punch/GloryKill", CHAN_WEAPON, CHANF_OVERLAP);
			A_GiveInventory("GloryKilled", 1, AAPTR_TRACER);
		}
		MFS2 CDEFH 1
		{
			EOA_SetGKRecoilOffset(-1.5, -1.5);
			EOA_SetGKRecoilOffset(-1.5, -1.5);
		}
		TNT1 A 2
		{
			EOA_SetGKRecoilOffset(-3);
			EOA_SetGKRecoilOffset(-3);
			A_SetTics(2 * (1 - (0.5 * CountInv("SavagerySelected") + 0.5 * (CountInv("SavagerySelected") && (CountInv("SavageryII"))))));
		}
		Goto GloryKillEnd;
	GloryKill3:
		MFST ABCDEFG 1 EOA_SetGKRecoilOffset(-3.5, 2.5, 1.5);
		TNT1 A 0 A_StartSound("BladeExtened", CHAN_WEAPON, CHANF_OVERLAP);
		BDFT ABB 1 EOA_SetGKRecoilOffset(-3.5, 2.5, 1.5);
		BDFT BCD 1 EOA_SetGKRecoilOffset(3.5, 2.5, -1.5);
		TNT1 A 0 
		{
			A_StartSound("BladeSlice", CHAN_WEAPON, CHANF_OVERLAP);
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKillPuff");
			A_GiveInventory("GloryKilled", 1, AAPTR_TRACER);
		}
		BDFT EFGH 1;
		TNT1 A 2
		{
			EOA_SetGKRecoilOffset(-3);
			EOA_SetGKRecoilOffset(-3);
			A_SetTics(2 * (1 - (0.5 * CountInv("SavagerySelected") + 0.5 * (CountInv("SavagerySelected") && (CountInv("SavageryII"))))));
		}
		Goto GloryKillEnd;
	GloryKill4:
		GKCS ACE 1 EOA_SetGKRecoilOffset(0.5, -4.5, 0.5);
		TNT1 A 0 
		{
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKillPuff");
			A_StartSound("Punch/GloryKill", CHAN_WEAPON, CHANF_OVERLAP);
			A_GiveInventory("GloryKilled", 1, AAPTR_TRACER);
		}
		GKCS FFFGGHIJ 1 EOA_SetGKRecoilOffset(0.15, -2.5, 0.15);
		TNT1 A 2
		{
			EOA_SetGKRecoilOffset(-3);
			EOA_SetGKRecoilOffset(-3);
			A_SetTics(2 * (1 - (0.5 * CountInv("SavagerySelected") + 0.5 * (CountInv("SavagerySelected") && (CountInv("SavageryII"))))));
		}
		Goto GloryKillEnd;
	GloryKill5: //Left side punch, right punch.
		TNT1 A 0 EOA_SetGKRecoilOffset(0, 15);
		GKSF ABC 1 EOA_SetGKRecoilOffset(-7, -2);
		TNT1 A 0
		{
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKillPuff");
			A_GiveInventory("GloryPunched", 1, AAPTR_TRACER);
		}
		GKSF DEFGH 1 EOA_SetGKRecoilOffset(-2, -2);
		TNT1 A 7
		{
			A_SetTics(7 * (1 - (0.5 * CountInv("SavagerySelected") + 0.5 * (CountInv("SavagerySelected") && (CountInv("SavageryII"))))));
			A_OverlayFlags(1, PSPF_FLIP|PSPF_MIRROR, 1);
		}
		GKFS AB 1 EOA_SetGKRecoilOffset(10.5, 7.5, -7.5);
		TNT1 A 0
		{
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKillPuff");
			A_GiveInventory("GloryKilled", 1, AAPTR_TRACER);
		}
		GKFS CDEFGH 1
		{
			EOA_SetGKRecoilOffset(1.5, -1.5);
			EOA_SetGKRecoilOffset(1.5, -1.5);
		}
		TNT1 A 2
		{
			EOA_SetGKRecoilOffset(3);
			EOA_SetGKRecoilOffset(3);
		}
		Goto GloryKillEnd;
	GloryKill6: //Leg stomp, left punch.
		TNT1 A 1
		{
			A_Overlay(10, "GloryHand");
			A_Overlay(-10, "GloryHand");
			A_OverlayFlags(-10, PSPF_FLIP|PSPF_MIRROR, 1);
			A_FaceTracer(90, 90, 0, 0, FAF_BOTTOM);
		}
		KICK ADH 1;
		KICK H 7
		{
			A_Overlay(10, "GloryFists");
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKickPuff");
			A_GiveInventory("GloryPunched", 1, AAPTR_TRACER);
			A_SetTics(7 * (1 - (0.5 * CountInv("SavagerySelected") + 0.5 * (CountInv("SavagerySelected") && (CountInv("SavageryII"))))));
		}
		KICK HGFEDCBA 1 A_SetPitch(Pitch - Pitch / 2, SPF_INTERPOLATE);
		TNT1 A 0
		{
			A_SetPitch(0, SPF_INTERPOLATE);
			A_OverlayFlags(1, PSPF_FLIP|PSPF_MIRROR, 1);
		}
		GKFS AB 1 EOA_SetGKRecoilOffset(10.5, 7.5, -7.5);
		TNT1 A 0
		{
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKillPuff");
			A_GiveInventory("GloryKilled", 1, AAPTR_TRACER);
		}
		GKFS CDEFGH 1
		{
			EOA_SetGKRecoilOffset(-1.5, 1.5);
			EOA_SetGKRecoilOffset(-1.5, 1.5);
		}
		TNT1 A 2
		{
			EOA_SetGKRecoilOffset(3);
			EOA_SetGKRecoilOffset(3);
		}
		Goto GloryKillEnd;
	GloryKill7: //Right side-kick, left punch.
		TNT1 A 0
		{
			A_OverlayFlags(1, PSPF_FLIP|PSPF_MIRROR, 1);
			EOA_SetGKRecoilOffset(-16);
		}
		GKKN ACE 1 EOA_SetGKRecoilOffset(4);
		GKSP CDE 1 EOA_SetGKRecoilOffset(8);
		TNT1 A 0
		{
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKickPuff");
			A_GiveInventory("GloryPunched", 1, AAPTR_TRACER);
		}
		GKSP DC 1;
		GKKN FDB 1;
		TNT1 A 7
		{
			A_OverlayFlags(1, PSPF_FLIP|PSPF_MIRROR, 0);
			A_SetTics(7 * (1 - (0.5 * CountInv("SavagerySelected") + 0.5 * (CountInv("SavagerySelected") && (CountInv("SavageryII"))))));
		}
		GKFS AB 1 EOA_SetGKRecoilOffset(-10.5, 7.5, 7.5);
		TNT1 A 0
		{
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKillPuff");
			A_GiveInventory("GloryKilled", 1, AAPTR_TRACER);
		}
		GKFS CDEFGH 1
		{
			EOA_SetGKRecoilOffset(-1.5, -1.5);
			EOA_SetGKRecoilOffset(-1.5, -1.5);
		}
		TNT1 A 2
		{
			EOA_SetGKRecoilOffset(3);
			EOA_SetGKRecoilOffset(3);
		}
		Goto GloryKillEnd;
	GloryKill8: //Right jab, right punch.
		FIST NP 1 EOA_SetGKRecoilOffset(7, 5, -5);
		TNT1 A 0
		{
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKillPuff");
			A_GiveInventory("GloryPunched", 1, AAPTR_TRACER);
		}
		FIST RSTUW 1 EOA_SetGKRecoilOffset(-2, -2);
		TNT1 A 2 EOA_SetGKRecoilOffset(-4);
		TNT1 A 7
		{
			A_SetTics(7 * (1 - (0.5 * CountInv("SavagerySelected") + 0.5 * (CountInv("SavagerySelected") && (CountInv("SavageryII"))))));
			A_OverlayFlags(1, PSPF_FLIP|PSPF_MIRROR, 1);
		}
		GKFS AB 1 EOA_SetGKRecoilOffset(10.5, 7.5, -7.5);
		TNT1 A 0
		{
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKillPuff");
			A_GiveInventory("GloryKilled", 1, AAPTR_TRACER);
		}
		GKFS CDEFGH 1
		{
			EOA_SetGKRecoilOffset(1.5, -1.5);
			EOA_SetGKRecoilOffset(1.5, -1.5);
		}
		TNT1 A 2
		{
			EOA_SetGKRecoilOffset(3);
			EOA_SetGKRecoilOffset(3);
		}
		Goto GloryKillEnd;
	GloryHand:
		GRBH DGEI 1;
		Stop;
	GloryFists:
		BFSR DCBAA 1;
		BFSR A 7 A_SetTics(7 * (1 - (0.5 * CountInv("SavagerySelected") + 0.5 * (CountInv("SavagerySelected") && (CountInv("SavageryII"))))));
		Stop;
	GloryKillEnd:
		TNT1 A 0 
		{
			A_WeaponOffset();
			SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
			A_OverlayFlags(1, PSPF_MIRROR|PSPF_FLIP, 0);
			bNOTARGET = bNOPAIN = bNODAMAGE = bNOGRAVITY = False;
			A_TakeInventory("RipAndTear");
			A_TakeInventory("DeathFromAbove");
			If (CountInv("ArmoredOffensiveSelected"))
			{
				EOA_SpawnNoiseMaker("Rune/ArmoredOffensive");
			}
			If (CountInv("BloodFueledSelected"))
			{
				EOA_SpawnNoiseMaker("Rune/BloodFueled");
				If (CountInv("BloodFueledII"))
				{
					A_GiveInventory("PowerBloodfueledEFX");
					A_GiveInventory("ExtendedBloodFueledSpeed");
				}
				Else
				{
					A_GiveInventory("PowerBloodfueledEFX");
					A_GiveInventory("BloodFueledSpeed");
				}
			}
		}	
		TNT1 A 0 A_Jump(256, "ReRaise");
		Goto ReRaise;
	DeathFromAbove:
		TNT1 A 0
		{
			A_TakeInventory("PowerStaggered", 0, 0, AAPTR_TRACER);
			A_TransferPointer(AAPTR_DEFAULT, AAPTR_TRACER, AAPTR_DEFAULT, AAPTR_TARGET);
			A_SetPitch(60, SPF_INTERPOLATE);
			A_Stop();
			Let Challenges = EOA_ChallengeArchive.Get();
			If (Challenges)
			{
				Challenges.QueueGK = True;
			}
			If (CountInv("SavagerySelected"))
			{
				EOA_SpawnNoiseMaker("Rune/Savagery");
				If (!CountInv("SavageryII") && SavageryQueue())
				{
					A_GiveInventory("SavageryChallengeCounter");
					A_GiveInventory("MasteryTicker");
				}
			}
			If (CountInv("SeekAndDestroySelected") && !CountInv("SeekAndDestroyII"))
			{
				A_GiveInventory("SeekAndDestroyChallengeCounter");
				A_GiveInventory("MasteryTicker");
			}
			If (CountInv("BloodFueledSelected") && !CountInv("BloodFueledII") && CountInv("PowerBloodFueledSpeed"))
			{
				A_GiveInventory("BloodFueledChallengeCounter");
				A_GiveInventory("MasteryTicker");
			}
			If (CountInv("SavingThrowSelected") && !CountInv("SavingThrowII") && CountInv("PowerSavingThrow"))
			{
				A_GiveInventory("SavingThrowChallengeCounter");
				A_GiveInventory("MasteryTicker");
			}
			If (CountInv("DazedAndConfusedSelected") && !CountInv("DazedAndConfusedII"))
			{
				A_GiveInventory("DazedAndConfusedChallengeCounter");
				A_GiveInventory("MasteryTicker");
			}
			If (CountInv("InFlightMobilitySelected") && !CountInv("InFlightMobilityII"))
			{
				A_GiveInventory("InFlightMobilityChallengeCounter");
				A_GiveInventory("MasteryTicker");
			}
			EOA_SetGKRecoilOffset(0, 0, randompick(-10, 10), True);
			A_Overlay(-10, "DeathFromAbove2");
			A_OverlayFlags(-10, PSPF_FLIP|PSPF_MIRROR, True);
			A_WeaponOffset(-35, 0, WOF_KEEPY);
			A_OverlayOffset(-10, -5, 0, WOF_KEEPY);
		}
		KICK ONML 1;
		TNT1 A 0
		{
			if(CountInv("HitAndRun"))
			{
				A_GiveInventory("B5_DDash", 2);
			}
			If(CountInv("BloodPunch"))
			{
				if(countinv("extrabloodpunchcounter") == 1)
				{
				EOA_spawnnoisemaker("BloodPunchCharged", 0);
				}
				if(countinv("ArmoredOffensiveSelected") && countinv("Bloodpunchcounter") == 2)
				{
					A_giveinventory("Extrabloodpunchcounter");
				}
				if(countinv("bloodpunchcounter") == 1)
				{
				EOA_spawnnoisemaker("BloodPunchCharged", 0);
				}
				EOA_spawnnoisemaker("GloryKillDing", 0);
				if(CountInv("ArmoredOffensiveSelected"))
				{
					A_CustomPunch(0, 0, CPF_NOTURN, "EnemyHealthChecker", 192);
				}
				if(!CountInv("ArmoredOffensiveSelected"))
				{
					A_giveinventory("bloodpunchcounter", 1);
				}	
				if(Countinv("ArmoredOffensiveSelected") && CountInv("bloodpunchcounter") > 1)
				{
					EOA_spawnnoisemaker("BloodPunchCharged", 0);
				}
			}
		}
		TNT1 A 0
		{
			A_CustomPunch(0, 1, CPF_NOTURN, "GloryKickPuff");
			A_GiveInventory("GloryKilled", 1, AAPTR_TRACER);
		}
		KICK KJIHGFEDCCC 1
		{
			A_SetPitch(60, SPF_INTERPOLATE);
			If (CountInv("SavagerySelected"))
			{
				If (CountInv("SavageryII"))
				{
					If (CountInv("SpeedCounter") >= 3)
					{
						A_TakeInventory("SpeedCounter");
					}
					Else
					{
						A_SetTics(0);
						A_GiveInventory("SpeedCounter");
					}
				}
				Else If (CountInv("SpeedCounter"))
				{
					A_TakeInventory("SpeedCounter");
				}
				Else
				{
					A_SetTics(0);
					A_GiveInventory("SpeedCounter");
				}
			}
		}
		KICK B 1 A_SetPitch(54, SPF_INTERPOLATE);
		KICK A 1 A_SetPitch(48, SPF_INTERPOLATE);
		TNT1 A 1 A_SetPitch(42, SPF_INTERPOLATE);
		TNT1 A 1 A_SetPitch(36, SPF_INTERPOLATE);
		TNT1 A 1 A_SetPitch(30, SPF_INTERPOLATE);
		TNT1 A 1 A_SetPitch(24, SPF_INTERPOLATE);
		TNT1 A 1 A_SetPitch(18, SPF_INTERPOLATE);
		TNT1 A 1 A_SetPitch(12, SPF_INTERPOLATE);
		TNT1 A 1 A_SetPitch(6, SPF_INTERPOLATE);
		TNT1 A 1 A_SetPitch(0, SPF_INTERPOLATE);
		Goto GloryKillEnd;
	DeathFromAbove2:
		KICK ONML 1;
		KICK KJIHGFEDCCCBA 1
		{
			If (CountInv("SavagerySelected"))
			{
				If (CountInv("SavageryII"))
				{
					If (CountInv("SpeedCounter") >= 3)
					{
						A_TakeInventory("SpeedCounter");
					}
					Else
					{
						A_SetTics(0);
						A_GiveInventory("SpeedCounter");
					}
				}
				Else If (CountInv("SpeedCounter"))
				{
					A_TakeInventory("SpeedCounter");
				}
				Else
				{
					A_SetTics(0);
					A_GiveInventory("SpeedCounter");
				}
			}
		}
		KICK BA 1;
		Stop;
	}
}

//this is here so that the Hud renderer wont break when interacting with something
Class EOA_InteractionAmmo : EOA_Ammo{}

Class EOA_InteractWeapon : EOA_Weapon
{
	Actor Giver;
	Actor Totem;
	Class<Weapon> ReselectWeapon;
	String YieldItem;
	Double ZoomFactor;
	Property ZoomFactor : ZoomFactor;
	Default
	{
		EOA_InteractWeapon.ZoomFactor 1.5;
		Weapon.UpSound "";
		Weapon.AmmoType1 "EOA_InteractionAmmo";
		Weapon.AmmoType2 "EOA_InteractionAmmo";
		+WEAPON.CHEATNOTWEAPON
	}
	States
	{
	Spawn:
		TNT1 A 1;
		Stop;
	Select:
		TNT1 A 0
		{
			For (Int i = 0; i <=9; i++)
			{
				Int Offset = i ? 0 : 50;
				EOA_DestroyPersistentNoiseMaker(i, 50, Offset);
			}
			If (Invoker.ReselectWeapon)
			{
				PowerBerserk BerserkPower = PowerBerserk(FindInventory("PowerBerserk"));
				If (BerserkPower)
				{
					Invoker.ReselectWeapon = BerserkPower.PrevWeapon.GetClass();
				}
			}
			SetPlayerProperty(0, 1, PROP_INSTANTWEAPONSWITCH);
			SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
			bDONTTHRUST = True;
			Invoker.FOVScale = 1;
			A_ZoomFactor(Invoker.ZoomFactor);
			A_SetCrosshair(99);
			A_Stop();
		}
		TNT1 A 1 A_Raise(60);
		Wait;
	Deselect:
		TNT1 A 1 
		{
			bDONTTHRUST = Default.bDONTTHRUST;
			A_ZoomFactor();
			If (Invoker.YieldItem)
			{
				A_GiveInventory(Invoker.YieldItem);
			}
			If (Invoker.ReselectWeapon)
			{
				A_SelectWeapon(Invoker.ReselectWeapon, SWF_SELECTPRIORITY);
			}
			A_Lower(36);
			A_TakeInventory(Invoker.GetClassName());
			SetPlayerProperty(0, 0, PROP_INSTANTWEAPONSWITCH);
			SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
		}
		Wait;
	Ready:
		Goto Deselect;
	Fire:
		Goto Ready;
	}
}

Class EOA_MeleePuff : Actor
{
	States
	{
	XDeath:
		TNT1 A 1
		{
			A_StartSound("Punch/GloryKill", 0);
			A_StartSound("Punch/Bass", 0);
		}
		Stop;
	Melee:
	Crash:
		TNT1 A 1
		{
			A_StartSound("Punch/Base", 0);
			A_StartSound("Punch/Bass", 0);
		}
		Stop;
	}
}

Class DeathFromAbove : EOA_Token{}

Class GloryKillPuff : BulletPuff
{
	Default
	{
		+ALWAYSPUFF
		+PUFFONACTORS
		+FOILINVUL
	}
	States
	{
	XDeath:
		TNT1 A 0
		{
			A_StartSound("Punch/GloryKill", 0);
			A_StartSound("Punch/Bass", 0);
		}
		Stop;
	Melee:
	Crash:
		TNT1 A 0
		{
			A_StartSound("Punch/GloryKill", 0);
			A_StartSound("Punch/Bass", 0);
		}
		Goto Super::Melee;
	}
}

Class GloryKickPuff : GloryKillPuff
{
	States
	{
	XDeath:
		TNT1 A 0 
		{
			A_StartSound("Punch/GloryKill", 0);
			A_StartSound("Punch/BoneSnap", 0);
		}
		Stop;
	Melee:
	Crash:
		TNT1 A 0 
		{
			A_StartSound("Punch/GloryKill", 0);
			A_StartSound("Punch/BoneSnap", 0);
		}
		Goto Super::Melee;
	}
}

Class EOA_MantleCooldown : Powerup
{
	Default
	{
		Powerup.Duration -1;
	}
	Override Void Tick()
	{
		If (!Owner || EffectTics <= 0)
		{
			Destroy();
			Return;
		}
		EffectTics -= 1 + Owner.CountInv("QuickHands");
	}
}

Class EOA_PersistentNoiseMaker : Actor
{
	Actor Owner;
	Bool Terminated;
	Int ID;
	Default
	{
		ReactionTime 35;
		+DONTBLAST
		+DONTTHRUST
		+NOINTERACTION
		+NOTIMEFREEZE
	}
	Override Void Tick()
	{
		If (Owner && ReactionTime-- > 0)
		{
			Warp(Owner, 0, 0, 0, 0, WARPF_NOCHECKPOSITION|WARPF_COPYINTERPOLATION, 0.5);
		}
		Else
		{
			Destroy();
			Return;
		}
	}
}

Class EOA_MeleeThinker : Thinker
{
	Actor Owner, Victim;
	Int Timer;
	Override Void Tick()
	{
		If (!Owner || !Victim || Owner.bKILLED || Victim.bKILLED || Owner.CountInv("RipAndTear") || Timer >= 4)
		{
			Destroy();
			Return;
		}
		Else
		{
			Bool Miss;
			Actor Ret;
			[Miss, Ret] = Owner.TestMobjZ();
			If (!Miss && Ret == Victim)
			{
				Destroy();
				Return;
			}
			Owner.A_Face(Victim, 90);
			Owner.A_ChangeVelocity(64, Flags: CVF_RELATIVE|CVF_REPLACE);
			Timer++;
		}
	}
	Override Void OnDestroy()
	{
		If (Owner && !Owner.CountInv("RipAndTear"))
		{
			Owner.A_Stop();
		}
	}
}

Class EOA_WeaponRecoilThinker : Thinker
{
	Actor Owner;
	Double RecoilAngle;
	Double RecoilPitch;
	Double RecoilRoll;
	Double RecoilFactor;
	Override Void Tick()
	{
		If (!Owner)
		{
			Destroy();
			Return;
		}
		If (abs(RecoilAngle) < RecoilFactor * (1 + Owner.CountInv("PowerHaste")) && abs(RecoilPitch) < RecoilFactor * (1 + Owner.CountInv("PowerHaste")) && abs(RecoilRoll) < RecoilFactor * (1 + Owner.CountInv("PowerHaste")))
		{
			Owner.A_SetAngle(Owner.Angle - RecoilAngle, SPF_INTERPOLATE);
			Owner.A_SetPitch(Owner.Pitch - RecoilPitch, SPF_INTERPOLATE);
			Owner.A_SetRoll(Owner.Roll - RecoilRoll, SPF_INTERPOLATE);
			Destroy();
			Return;
		}
		Owner.A_SetAngle(Owner.Angle - RecoilAngle / max(1, abs(RecoilAngle)) * RecoilFactor * (1 + Owner.CountInv("PowerHaste")), SPF_INTERPOLATE);
		Owner.A_SetPitch(Owner.Pitch - RecoilPitch / max(1, abs(RecoilPitch)) * RecoilFactor * (1 + Owner.CountInv("PowerHaste")), SPF_INTERPOLATE);
		Owner.A_SetRoll(Owner.Roll - RecoilRoll / max(1, abs(RecoilRoll)) * RecoilFactor * (1 + Owner.CountInv("PowerHaste")), SPF_INTERPOLATE);
		RecoilAngle -= RecoilAngle / max(1, abs(RecoilAngle)) * RecoilFactor * (1 + Owner.CountInv("PowerHaste"));
		RecoilPitch -= RecoilPitch / max(1, abs(RecoilPitch)) * RecoilFactor * (1 + Owner.CountInv("PowerHaste"));
		RecoilRoll -= RecoilRoll / max(1, abs(RecoilRoll)) * RecoilFactor * (1 + Owner.CountInv("PowerHaste"));
	}
}

Class EOA_GKRecoilThinker : EOA_WeaponRecoilThinker
{
	Bool Ignore;
	Override Void Tick()
	{
		If (!Owner)
		{
			Destroy();
			Return;
		}
		If (abs(RecoilAngle) < RecoilFactor * (!Ignore ? 1 : (1 + 0.5 * Owner.CountInv("SavagerySelected") + (Owner.CountInv("SavagerySelected") * Owner.CountInv("SavageryII")))) && abs(RecoilPitch) < RecoilFactor * (!Ignore ? 1 : (1 + 0.5 * Owner.CountInv("SavagerySelected") + (Owner.CountInv("SavagerySelected") * Owner.CountInv("SavageryII")))) && abs(RecoilRoll) < RecoilFactor * (!Ignore ? 1 : (1 + 0.5 * Owner.CountInv("SavagerySelected") + (Owner.CountInv("SavagerySelected") * Owner.CountInv("SavageryII")))))
		{
			Owner.A_SetAngle(Owner.Angle - RecoilAngle, SPF_INTERPOLATE);
			Owner.A_SetPitch(Owner.Pitch - RecoilPitch, SPF_INTERPOLATE);
			Owner.A_SetRoll(Owner.Roll - RecoilRoll, SPF_INTERPOLATE);
			Destroy();
			Return;
		}
		Owner.A_SetAngle(Owner.Angle - RecoilAngle / max(1, abs(RecoilAngle)) * RecoilFactor * (!Ignore ? 1 : (1 + 0.5 * Owner.CountInv("SavagerySelected") + (Owner.CountInv("SavagerySelected") * Owner.CountInv("SavageryII")))), SPF_INTERPOLATE);
		Owner.A_SetPitch(Owner.Pitch - RecoilPitch / max(1, abs(RecoilPitch)) * RecoilFactor * (!Ignore ? 1 : (1 + 0.5 * Owner.CountInv("SavagerySelected") + (Owner.CountInv("SavagerySelected") * Owner.CountInv("SavageryII")))), SPF_INTERPOLATE);
		Owner.A_SetRoll(Owner.Roll - RecoilRoll / max(1, abs(RecoilRoll)) * RecoilFactor * (!Ignore ? 1 : (1 + 0.5 * Owner.CountInv("SavagerySelected") + (Owner.CountInv("SavagerySelected") * Owner.CountInv("SavageryII")))), SPF_INTERPOLATE);
		RecoilAngle -= RecoilAngle / max(1, abs(RecoilAngle)) * RecoilFactor * (!Ignore ? 1 : (1 + 0.5 * Owner.CountInv("SavagerySelected") + (Owner.CountInv("SavagerySelected") * Owner.CountInv("SavageryII"))));
		RecoilPitch -= RecoilPitch / max(1, abs(RecoilPitch)) * RecoilFactor * (!Ignore ? 1 : (1 + 0.5 * Owner.CountInv("SavagerySelected") + (Owner.CountInv("SavagerySelected") * Owner.CountInv("SavageryII"))));
		RecoilRoll -= RecoilRoll / max(1, abs(RecoilRoll)) * RecoilFactor * (!Ignore ? 1 : (1 + 0.5 * Owner.CountInv("SavagerySelected") + (Owner.CountInv("SavagerySelected") * Owner.CountInv("SavageryII"))));
	}
}